{"ast":null,"code":"import _createForOfIteratorHelper from \"/root/code/amandaaurora/chess-pgn-react/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/root/code/amandaaurora/chess-pgn-react/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/root/code/amandaaurora/chess-pgn-react/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _defineProperty from \"/root/code/amandaaurora/chess-pgn-react/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nvar _SIDES;\n/**\n * @license\n * Copyright (c) 2023, Jeff Hlywa (jhlywa@gmail.com)\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\nexport var WHITE = 'w';\nexport var BLACK = 'b';\nexport var PAWN = 'p';\nexport var KNIGHT = 'n';\nexport var BISHOP = 'b';\nexport var ROOK = 'r';\nexport var QUEEN = 'q';\nexport var KING = 'k';\nexport var DEFAULT_POSITION = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';\nvar EMPTY = -1;\nvar FLAGS = {\n  NORMAL: 'n',\n  CAPTURE: 'c',\n  BIG_PAWN: 'b',\n  EP_CAPTURE: 'e',\n  PROMOTION: 'p',\n  KSIDE_CASTLE: 'k',\n  QSIDE_CASTLE: 'q'\n};\n// prettier-ignore\nexport var SQUARES = ['a8', 'b8', 'c8', 'd8', 'e8', 'f8', 'g8', 'h8', 'a7', 'b7', 'c7', 'd7', 'e7', 'f7', 'g7', 'h7', 'a6', 'b6', 'c6', 'd6', 'e6', 'f6', 'g6', 'h6', 'a5', 'b5', 'c5', 'd5', 'e5', 'f5', 'g5', 'h5', 'a4', 'b4', 'c4', 'd4', 'e4', 'f4', 'g4', 'h4', 'a3', 'b3', 'c3', 'd3', 'e3', 'f3', 'g3', 'h3', 'a2', 'b2', 'c2', 'd2', 'e2', 'f2', 'g2', 'h2', 'a1', 'b1', 'c1', 'd1', 'e1', 'f1', 'g1', 'h1'];\nvar BITS = {\n  NORMAL: 1,\n  CAPTURE: 2,\n  BIG_PAWN: 4,\n  EP_CAPTURE: 8,\n  PROMOTION: 16,\n  KSIDE_CASTLE: 32,\n  QSIDE_CASTLE: 64\n};\n/*\n * NOTES ABOUT 0x88 MOVE GENERATION ALGORITHM\n * ----------------------------------------------------------------------------\n * From https://github.com/jhlywa/chess.js/issues/230\n *\n * A lot of people are confused when they first see the internal representation\n * of chess.js. It uses the 0x88 Move Generation Algorithm which internally\n * stores the board as an 8x16 array. This is purely for efficiency but has a\n * couple of interesting benefits:\n *\n * 1. 0x88 offers a very inexpensive \"off the board\" check. Bitwise AND (&) any\n *    square with 0x88, if the result is non-zero then the square is off the\n *    board. For example, assuming a knight square A8 (0 in 0x88 notation),\n *    there are 8 possible directions in which the knight can move. These\n *    directions are relative to the 8x16 board and are stored in the\n *    PIECE_OFFSETS map. One possible move is A8 - 18 (up one square, and two\n *    squares to the left - which is off the board). 0 - 18 = -18 & 0x88 = 0x88\n *    (because of two-complement representation of -18). The non-zero result\n *    means the square is off the board and the move is illegal. Take the\n *    opposite move (from A8 to C7), 0 + 18 = 18 & 0x88 = 0. A result of zero\n *    means the square is on the board.\n *\n * 2. The relative distance (or difference) between two squares on a 8x16 board\n *    is unique and can be used to inexpensively determine if a piece on a\n *    square can attack any other arbitrary square. For example, let's see if a\n *    pawn on E7 can attack E2. The difference between E7 (20) - E2 (100) is\n *    -80. We add 119 to make the ATTACKS array index non-negative (because the\n *    worst case difference is A8 - H1 = -119). The ATTACKS array contains a\n *    bitmask of pieces that can attack from that distance and direction.\n *    ATTACKS[-80 + 119=39] gives us 24 or 0b11000 in binary. Look at the\n *    PIECE_MASKS map to determine the mask for a given piece type. In our pawn\n *    example, we would check to see if 24 & 0x1 is non-zero, which it is\n *    not. So, naturally, a pawn on E7 can't attack a piece on E2. However, a\n *    rook can since 24 & 0x8 is non-zero. The only thing left to check is that\n *    there are no blocking pieces between E7 and E2. That's where the RAYS\n *    array comes in. It provides an offset (in this case 16) to add to E7 (20)\n *    to check for blocking pieces. E7 (20) + 16 = E6 (36) + 16 = E5 (52) etc.\n */\n// prettier-ignore\n// eslint-disable-next-line\nvar Ox88 = {\n  a8: 0,\n  b8: 1,\n  c8: 2,\n  d8: 3,\n  e8: 4,\n  f8: 5,\n  g8: 6,\n  h8: 7,\n  a7: 16,\n  b7: 17,\n  c7: 18,\n  d7: 19,\n  e7: 20,\n  f7: 21,\n  g7: 22,\n  h7: 23,\n  a6: 32,\n  b6: 33,\n  c6: 34,\n  d6: 35,\n  e6: 36,\n  f6: 37,\n  g6: 38,\n  h6: 39,\n  a5: 48,\n  b5: 49,\n  c5: 50,\n  d5: 51,\n  e5: 52,\n  f5: 53,\n  g5: 54,\n  h5: 55,\n  a4: 64,\n  b4: 65,\n  c4: 66,\n  d4: 67,\n  e4: 68,\n  f4: 69,\n  g4: 70,\n  h4: 71,\n  a3: 80,\n  b3: 81,\n  c3: 82,\n  d3: 83,\n  e3: 84,\n  f3: 85,\n  g3: 86,\n  h3: 87,\n  a2: 96,\n  b2: 97,\n  c2: 98,\n  d2: 99,\n  e2: 100,\n  f2: 101,\n  g2: 102,\n  h2: 103,\n  a1: 112,\n  b1: 113,\n  c1: 114,\n  d1: 115,\n  e1: 116,\n  f1: 117,\n  g1: 118,\n  h1: 119\n};\nvar PAWN_OFFSETS = {\n  b: [16, 32, 17, 15],\n  w: [-16, -32, -17, -15]\n};\nvar PIECE_OFFSETS = {\n  n: [-18, -33, -31, -14, 18, 33, 31, 14],\n  b: [-17, -15, 17, 15],\n  r: [-16, 1, 16, -1],\n  q: [-17, -16, -15, 1, 17, 16, 15, -1],\n  k: [-17, -16, -15, 1, 17, 16, 15, -1]\n};\n// prettier-ignore\nvar ATTACKS = [20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20, 0, 0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0, 0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0, 24, 24, 24, 24, 24, 24, 56, 0, 56, 24, 24, 24, 24, 24, 24, 0, 0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0, 20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20];\n// prettier-ignore\nvar RAYS = [17, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 15, 0, 0, 17, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 15, 0, 0, 0, 0, 17, 0, 0, 0, 0, 16, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 17, 0, 0, 0, 16, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 17, 0, 0, 16, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 0, 16, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 16, 15, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, -15, -16, -17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -15, 0, -16, 0, -17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -15, 0, 0, -16, 0, 0, -17, 0, 0, 0, 0, 0, 0, 0, 0, -15, 0, 0, 0, -16, 0, 0, 0, -17, 0, 0, 0, 0, 0, 0, -15, 0, 0, 0, 0, -16, 0, 0, 0, 0, -17, 0, 0, 0, 0, -15, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, -17, 0, 0, -15, 0, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, 0, -17];\nvar PIECE_MASKS = {\n  p: 0x1,\n  n: 0x2,\n  b: 0x4,\n  r: 0x8,\n  q: 0x10,\n  k: 0x20\n};\nvar SYMBOLS = 'pnbrqkPNBRQK';\nvar PROMOTIONS = [KNIGHT, BISHOP, ROOK, QUEEN];\nvar RANK_1 = 7;\nvar RANK_2 = 6;\n/*\n * const RANK_3 = 5\n * const RANK_4 = 4\n * const RANK_5 = 3\n * const RANK_6 = 2\n */\nvar RANK_7 = 1;\nvar RANK_8 = 0;\nvar SIDES = (_SIDES = {}, _defineProperty(_SIDES, KING, BITS.KSIDE_CASTLE), _defineProperty(_SIDES, QUEEN, BITS.QSIDE_CASTLE), _SIDES);\nvar ROOKS = {\n  w: [{\n    square: Ox88.a1,\n    flag: BITS.QSIDE_CASTLE\n  }, {\n    square: Ox88.h1,\n    flag: BITS.KSIDE_CASTLE\n  }],\n  b: [{\n    square: Ox88.a8,\n    flag: BITS.QSIDE_CASTLE\n  }, {\n    square: Ox88.h8,\n    flag: BITS.KSIDE_CASTLE\n  }]\n};\nvar SECOND_RANK = {\n  b: RANK_7,\n  w: RANK_2\n};\nvar TERMINATION_MARKERS = ['1-0', '0-1', '1/2-1/2', '*'];\n// Extracts the zero-based rank of an 0x88 square.\nfunction rank(square) {\n  return square >> 4;\n}\n// Extracts the zero-based file of an 0x88 square.\nfunction file(square) {\n  return square & 0xf;\n}\nfunction isDigit(c) {\n  return '0123456789'.indexOf(c) !== -1;\n}\n// Converts a 0x88 square to algebraic notation.\nfunction algebraic(square) {\n  var f = file(square);\n  var r = rank(square);\n  return 'abcdefgh'.substring(f, f + 1) + '87654321'.substring(r, r + 1);\n}\nfunction swapColor(color) {\n  return color === WHITE ? BLACK : WHITE;\n}\nexport function validateFen(fen) {\n  // 1st criterion: 6 space-seperated fields?\n  var tokens = fen.split(/\\s+/);\n  if (tokens.length !== 6) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: must contain six space-delimited fields'\n    };\n  }\n  // 2nd criterion: move number field is a integer value > 0?\n  var moveNumber = parseInt(tokens[5], 10);\n  if (isNaN(moveNumber) || moveNumber <= 0) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: move number must be a positive integer'\n    };\n  }\n  // 3rd criterion: half move counter is an integer >= 0?\n  var halfMoves = parseInt(tokens[4], 10);\n  if (isNaN(halfMoves) || halfMoves < 0) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: half move counter number must be a non-negative integer'\n    };\n  }\n  // 4th criterion: 4th field is a valid e.p.-string?\n  if (!/^(-|[abcdefgh][36])$/.test(tokens[3])) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: en-passant square is invalid'\n    };\n  }\n  // 5th criterion: 3th field is a valid castle-string?\n  if (/[^kKqQ-]/.test(tokens[2])) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: castling availability is invalid'\n    };\n  }\n  // 6th criterion: 2nd field is \"w\" (white) or \"b\" (black)?\n  if (!/^(w|b)$/.test(tokens[1])) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: side-to-move is invalid'\n    };\n  }\n  // 7th criterion: 1st field contains 8 rows?\n  var rows = tokens[0].split('/');\n  if (rows.length !== 8) {\n    return {\n      ok: false,\n      error: \"Invalid FEN: piece data does not contain 8 '/'-delimited rows\"\n    };\n  }\n  // 8th criterion: every row is valid?\n  for (var i = 0; i < rows.length; i++) {\n    // check for right sum of fields AND not two numbers in succession\n    var sumFields = 0;\n    var previousWasNumber = false;\n    for (var k = 0; k < rows[i].length; k++) {\n      if (isDigit(rows[i][k])) {\n        if (previousWasNumber) {\n          return {\n            ok: false,\n            error: 'Invalid FEN: piece data is invalid (consecutive number)'\n          };\n        }\n        sumFields += parseInt(rows[i][k], 10);\n        previousWasNumber = true;\n      } else {\n        if (!/^[prnbqkPRNBQK]$/.test(rows[i][k])) {\n          return {\n            ok: false,\n            error: 'Invalid FEN: piece data is invalid (invalid piece)'\n          };\n        }\n        sumFields += 1;\n        previousWasNumber = false;\n      }\n    }\n    if (sumFields !== 8) {\n      return {\n        ok: false,\n        error: 'Invalid FEN: piece data is invalid (too many squares in rank)'\n      };\n    }\n  }\n  if (tokens[3][1] == '3' && tokens[1] == 'w' || tokens[3][1] == '6' && tokens[1] == 'b') {\n    return {\n      ok: false,\n      error: 'Invalid FEN: illegal en-passant square'\n    };\n  }\n  var kings = [{\n    color: 'white',\n    regex: /K/g\n  }, {\n    color: 'black',\n    regex: /k/g\n  }];\n  for (var _i = 0, _kings = kings; _i < _kings.length; _i++) {\n    var _kings$_i = _kings[_i],\n      color = _kings$_i.color,\n      regex = _kings$_i.regex;\n    if (!regex.test(tokens[0])) {\n      return {\n        ok: false,\n        error: \"Invalid FEN: missing \".concat(color, \" king\")\n      };\n    }\n    if ((tokens[0].match(regex) || []).length > 1) {\n      return {\n        ok: false,\n        error: \"Invalid FEN: too many \".concat(color, \" kings\")\n      };\n    }\n  }\n  return {\n    ok: true\n  };\n}\n// this function is used to uniquely identify ambiguous moves\nfunction getDisambiguator(move, moves) {\n  var from = move.from;\n  var to = move.to;\n  var piece = move.piece;\n  var ambiguities = 0;\n  var sameRank = 0;\n  var sameFile = 0;\n  for (var i = 0, len = moves.length; i < len; i++) {\n    var ambigFrom = moves[i].from;\n    var ambigTo = moves[i].to;\n    var ambigPiece = moves[i].piece;\n    /*\n     * if a move of the same piece type ends on the same to square, we'll need\n     * to add a disambiguator to the algebraic notation\n     */\n    if (piece === ambigPiece && from !== ambigFrom && to === ambigTo) {\n      ambiguities++;\n      if (rank(from) === rank(ambigFrom)) {\n        sameRank++;\n      }\n      if (file(from) === file(ambigFrom)) {\n        sameFile++;\n      }\n    }\n  }\n  if (ambiguities > 0) {\n    if (sameRank > 0 && sameFile > 0) {\n      /*\n       * if there exists a similar moving piece on the same rank and file as\n       * the move in question, use the square as the disambiguator\n       */\n      return algebraic(from);\n    } else if (sameFile > 0) {\n      /*\n       * if the moving piece rests on the same file, use the rank symbol as the\n       * disambiguator\n       */\n      return algebraic(from).charAt(1);\n    } else {\n      // else use the file symbol\n      return algebraic(from).charAt(0);\n    }\n  }\n  return '';\n}\nfunction addMove(moves, color, from, to, piece) {\n  var captured = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : undefined;\n  var flags = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : BITS.NORMAL;\n  var r = rank(to);\n  if (piece === PAWN && (r === RANK_1 || r === RANK_8)) {\n    for (var i = 0; i < PROMOTIONS.length; i++) {\n      var promotion = PROMOTIONS[i];\n      moves.push({\n        color: color,\n        from: from,\n        to: to,\n        piece: piece,\n        captured: captured,\n        promotion: promotion,\n        flags: flags | BITS.PROMOTION\n      });\n    }\n  } else {\n    moves.push({\n      color: color,\n      from: from,\n      to: to,\n      piece: piece,\n      captured: captured,\n      flags: flags\n    });\n  }\n}\nfunction inferPieceType(san) {\n  var pieceType = san.charAt(0);\n  if (pieceType >= 'a' && pieceType <= 'h') {\n    var matches = san.match(/[a-h]\\d.*[a-h]\\d/);\n    if (matches) {\n      return undefined;\n    }\n    return PAWN;\n  }\n  pieceType = pieceType.toLowerCase();\n  if (pieceType === 'o') {\n    return KING;\n  }\n  return pieceType;\n}\n// parses all of the decorators out of a SAN string\nfunction strippedSan(move) {\n  return move.replace(/=/, '').replace(/[+#]?[?!]*$/, '');\n}\nexport var Chess = /*#__PURE__*/function () {\n  function Chess() {\n    var fen = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_POSITION;\n    _classCallCheck(this, Chess);\n    _defineProperty(this, \"_board\", new Array(128));\n    _defineProperty(this, \"_turn\", WHITE);\n    _defineProperty(this, \"_header\", {});\n    _defineProperty(this, \"_kings\", {\n      w: EMPTY,\n      b: EMPTY\n    });\n    _defineProperty(this, \"_epSquare\", -1);\n    _defineProperty(this, \"_halfMoves\", 0);\n    _defineProperty(this, \"_moveNumber\", 0);\n    _defineProperty(this, \"_history\", []);\n    _defineProperty(this, \"_comments\", {});\n    _defineProperty(this, \"_castling\", {\n      w: 0,\n      b: 0\n    });\n    this.load(fen);\n  }\n  _createClass(Chess, [{\n    key: \"clear\",\n    value: function clear() {\n      var keepHeaders = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      this._board = new Array(128);\n      this._kings = {\n        w: EMPTY,\n        b: EMPTY\n      };\n      this._turn = WHITE;\n      this._castling = {\n        w: 0,\n        b: 0\n      };\n      this._epSquare = EMPTY;\n      this._halfMoves = 0;\n      this._moveNumber = 1;\n      this._history = [];\n      this._comments = {};\n      this._header = keepHeaders ? this._header : {};\n      this._updateSetup(this.fen());\n    }\n  }, {\n    key: \"removeHeader\",\n    value: function removeHeader(key) {\n      if (key in this._header) {\n        delete this._header[key];\n      }\n    }\n  }, {\n    key: \"load\",\n    value: function load(fen) {\n      var keepHeaders = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var tokens = fen.split(/\\s+/);\n      // append commonly omitted fen tokens\n      if (tokens.length >= 2 && tokens.length < 6) {\n        var adjustments = ['-', '-', '0', '1'];\n        fen = tokens.concat(adjustments.slice(-(6 - tokens.length))).join(' ');\n      }\n      tokens = fen.split(/\\s+/);\n      var _validateFen = validateFen(fen),\n        ok = _validateFen.ok,\n        error = _validateFen.error;\n      if (!ok) {\n        throw new Error(error);\n      }\n      var position = tokens[0];\n      var square = 0;\n      this.clear(keepHeaders);\n      for (var i = 0; i < position.length; i++) {\n        var piece = position.charAt(i);\n        if (piece === '/') {\n          square += 8;\n        } else if (isDigit(piece)) {\n          square += parseInt(piece, 10);\n        } else {\n          var color = piece < 'a' ? WHITE : BLACK;\n          this.put({\n            type: piece.toLowerCase(),\n            color: color\n          }, algebraic(square));\n          square++;\n        }\n      }\n      this._turn = tokens[1];\n      if (tokens[2].indexOf('K') > -1) {\n        this._castling.w |= BITS.KSIDE_CASTLE;\n      }\n      if (tokens[2].indexOf('Q') > -1) {\n        this._castling.w |= BITS.QSIDE_CASTLE;\n      }\n      if (tokens[2].indexOf('k') > -1) {\n        this._castling.b |= BITS.KSIDE_CASTLE;\n      }\n      if (tokens[2].indexOf('q') > -1) {\n        this._castling.b |= BITS.QSIDE_CASTLE;\n      }\n      this._epSquare = tokens[3] === '-' ? EMPTY : Ox88[tokens[3]];\n      this._halfMoves = parseInt(tokens[4], 10);\n      this._moveNumber = parseInt(tokens[5], 10);\n      this._updateSetup(this.fen());\n    }\n  }, {\n    key: \"fen\",\n    value: function fen() {\n      var empty = 0;\n      var fen = '';\n      for (var i = Ox88.a8; i <= Ox88.h1; i++) {\n        if (this._board[i]) {\n          if (empty > 0) {\n            fen += empty;\n            empty = 0;\n          }\n          var _this$_board$i = this._board[i],\n            color = _this$_board$i.color,\n            piece = _this$_board$i.type;\n          fen += color === WHITE ? piece.toUpperCase() : piece.toLowerCase();\n        } else {\n          empty++;\n        }\n        if (i + 1 & 0x88) {\n          if (empty > 0) {\n            fen += empty;\n          }\n          if (i !== Ox88.h1) {\n            fen += '/';\n          }\n          empty = 0;\n          i += 8;\n        }\n      }\n      var castling = '';\n      if (this._castling[WHITE] & BITS.KSIDE_CASTLE) {\n        castling += 'K';\n      }\n      if (this._castling[WHITE] & BITS.QSIDE_CASTLE) {\n        castling += 'Q';\n      }\n      if (this._castling[BLACK] & BITS.KSIDE_CASTLE) {\n        castling += 'k';\n      }\n      if (this._castling[BLACK] & BITS.QSIDE_CASTLE) {\n        castling += 'q';\n      }\n      // do we have an empty castling flag?\n      castling = castling || '-';\n      var epSquare = '-';\n      /*\n       * only print the ep square if en passant is a valid move (pawn is present\n       * and ep capture is not pinned)\n       */\n      if (this._epSquare !== EMPTY) {\n        var bigPawnSquare = this._epSquare + (this._turn === WHITE ? 16 : -16);\n        var squares = [bigPawnSquare + 1, bigPawnSquare - 1];\n        for (var _i2 = 0, _squares = squares; _i2 < _squares.length; _i2++) {\n          var _this$_board$square, _this$_board$square2;\n          var square = _squares[_i2];\n          // is the square off the board?\n          if (square & 0x88) {\n            continue;\n          }\n          var _color = this._turn;\n          // is there a pawn that can capture the epSquare?\n          if (((_this$_board$square = this._board[square]) === null || _this$_board$square === void 0 ? void 0 : _this$_board$square.color) === _color && ((_this$_board$square2 = this._board[square]) === null || _this$_board$square2 === void 0 ? void 0 : _this$_board$square2.type) === PAWN) {\n            // if the pawn makes an ep capture, does it leave it's king in check?\n            this._makeMove({\n              color: _color,\n              from: square,\n              to: this._epSquare,\n              piece: PAWN,\n              captured: PAWN,\n              flags: BITS.EP_CAPTURE\n            });\n            var isLegal = !this._isKingAttacked(_color);\n            this._undoMove();\n            // if ep is legal, break and set the ep square in the FEN output\n            if (isLegal) {\n              epSquare = algebraic(this._epSquare);\n              break;\n            }\n          }\n        }\n      }\n      return [fen, this._turn, castling, epSquare, this._halfMoves, this._moveNumber].join(' ');\n    }\n    /*\n     * Called when the initial board setup is changed with put() or remove().\n     * modifies the SetUp and FEN properties of the header object. If the FEN\n     * is equal to the default position, the SetUp and FEN are deleted the setup\n     * is only updated if history.length is zero, ie moves haven't been made.\n     */\n  }, {\n    key: \"_updateSetup\",\n    value: function _updateSetup(fen) {\n      if (this._history.length > 0) return;\n      if (fen !== DEFAULT_POSITION) {\n        this._header['SetUp'] = '1';\n        this._header['FEN'] = fen;\n      } else {\n        delete this._header['SetUp'];\n        delete this._header['FEN'];\n      }\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.load(DEFAULT_POSITION);\n    }\n  }, {\n    key: \"get\",\n    value: function get(square) {\n      return this._board[Ox88[square]] || false;\n    }\n  }, {\n    key: \"put\",\n    value: function put(_ref, square) {\n      var type = _ref.type,\n        color = _ref.color;\n      // check for piece\n      if (SYMBOLS.indexOf(type.toLowerCase()) === -1) {\n        return false;\n      }\n      // check for valid square\n      if (!(square in Ox88)) {\n        return false;\n      }\n      var sq = Ox88[square];\n      // don't let the user place more than one king\n      if (type == KING && !(this._kings[color] == EMPTY || this._kings[color] == sq)) {\n        return false;\n      }\n      this._board[sq] = {\n        type: type,\n        color: color\n      };\n      if (type === KING) {\n        this._kings[color] = sq;\n      }\n      this._updateCastlingRights();\n      this._updateEnPassantSquare();\n      this._updateSetup(this.fen());\n      return true;\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(square) {\n      var piece = this.get(square);\n      delete this._board[Ox88[square]];\n      if (piece && piece.type === KING) {\n        this._kings[piece.color] = EMPTY;\n      }\n      this._updateCastlingRights();\n      this._updateEnPassantSquare();\n      this._updateSetup(this.fen());\n      return piece;\n    }\n  }, {\n    key: \"_updateCastlingRights\",\n    value: function _updateCastlingRights() {\n      var _this$_board$Ox88$e, _this$_board$Ox88$e2, _this$_board$Ox88$e3, _this$_board$Ox88$e4, _this$_board$Ox88$a, _this$_board$Ox88$a2, _this$_board$Ox88$h, _this$_board$Ox88$h2, _this$_board$Ox88$a3, _this$_board$Ox88$a4, _this$_board$Ox88$h3, _this$_board$Ox88$h4;\n      var whiteKingInPlace = ((_this$_board$Ox88$e = this._board[Ox88.e1]) === null || _this$_board$Ox88$e === void 0 ? void 0 : _this$_board$Ox88$e.type) === KING && ((_this$_board$Ox88$e2 = this._board[Ox88.e1]) === null || _this$_board$Ox88$e2 === void 0 ? void 0 : _this$_board$Ox88$e2.color) === WHITE;\n      var blackKingInPlace = ((_this$_board$Ox88$e3 = this._board[Ox88.e8]) === null || _this$_board$Ox88$e3 === void 0 ? void 0 : _this$_board$Ox88$e3.type) === KING && ((_this$_board$Ox88$e4 = this._board[Ox88.e8]) === null || _this$_board$Ox88$e4 === void 0 ? void 0 : _this$_board$Ox88$e4.color) === BLACK;\n      if (!whiteKingInPlace || ((_this$_board$Ox88$a = this._board[Ox88.a1]) === null || _this$_board$Ox88$a === void 0 ? void 0 : _this$_board$Ox88$a.type) !== ROOK || ((_this$_board$Ox88$a2 = this._board[Ox88.a1]) === null || _this$_board$Ox88$a2 === void 0 ? void 0 : _this$_board$Ox88$a2.color) !== WHITE) {\n        this._castling.w &= ~BITS.QSIDE_CASTLE;\n      }\n      if (!whiteKingInPlace || ((_this$_board$Ox88$h = this._board[Ox88.h1]) === null || _this$_board$Ox88$h === void 0 ? void 0 : _this$_board$Ox88$h.type) !== ROOK || ((_this$_board$Ox88$h2 = this._board[Ox88.h1]) === null || _this$_board$Ox88$h2 === void 0 ? void 0 : _this$_board$Ox88$h2.color) !== WHITE) {\n        this._castling.w &= ~BITS.KSIDE_CASTLE;\n      }\n      if (!blackKingInPlace || ((_this$_board$Ox88$a3 = this._board[Ox88.a8]) === null || _this$_board$Ox88$a3 === void 0 ? void 0 : _this$_board$Ox88$a3.type) !== ROOK || ((_this$_board$Ox88$a4 = this._board[Ox88.a8]) === null || _this$_board$Ox88$a4 === void 0 ? void 0 : _this$_board$Ox88$a4.color) !== BLACK) {\n        this._castling.b &= ~BITS.QSIDE_CASTLE;\n      }\n      if (!blackKingInPlace || ((_this$_board$Ox88$h3 = this._board[Ox88.h8]) === null || _this$_board$Ox88$h3 === void 0 ? void 0 : _this$_board$Ox88$h3.type) !== ROOK || ((_this$_board$Ox88$h4 = this._board[Ox88.h8]) === null || _this$_board$Ox88$h4 === void 0 ? void 0 : _this$_board$Ox88$h4.color) !== BLACK) {\n        this._castling.b &= ~BITS.KSIDE_CASTLE;\n      }\n    }\n  }, {\n    key: \"_updateEnPassantSquare\",\n    value: function _updateEnPassantSquare() {\n      var _this$_board$currentS,\n        _this$_board$currentS2,\n        _this = this;\n      if (this._epSquare === EMPTY) {\n        return;\n      }\n      var startSquare = this._epSquare + (this._turn === WHITE ? -16 : 16);\n      var currentSquare = this._epSquare + (this._turn === WHITE ? 16 : -16);\n      var attackers = [currentSquare + 1, currentSquare - 1];\n      if (this._board[startSquare] !== null || this._board[this._epSquare] !== null || ((_this$_board$currentS = this._board[currentSquare]) === null || _this$_board$currentS === void 0 ? void 0 : _this$_board$currentS.color) !== swapColor(this._turn) || ((_this$_board$currentS2 = this._board[currentSquare]) === null || _this$_board$currentS2 === void 0 ? void 0 : _this$_board$currentS2.type) !== PAWN) {\n        this._epSquare = EMPTY;\n        return;\n      }\n      var canCapture = function canCapture(square) {\n        var _this$_board$square3, _this$_board$square4;\n        return !(square & 0x88) && ((_this$_board$square3 = _this._board[square]) === null || _this$_board$square3 === void 0 ? void 0 : _this$_board$square3.color) === _this._turn && ((_this$_board$square4 = _this._board[square]) === null || _this$_board$square4 === void 0 ? void 0 : _this$_board$square4.type) === PAWN;\n      };\n      if (!attackers.some(canCapture)) {\n        this._epSquare = EMPTY;\n      }\n    }\n  }, {\n    key: \"_attacked\",\n    value: function _attacked(color, square) {\n      for (var i = Ox88.a8; i <= Ox88.h1; i++) {\n        // did we run off the end of the board\n        if (i & 0x88) {\n          i += 7;\n          continue;\n        }\n        // if empty square or wrong color\n        if (this._board[i] === undefined || this._board[i].color !== color) {\n          continue;\n        }\n        var piece = this._board[i];\n        var difference = i - square;\n        // skip - to/from square are the same\n        if (difference === 0) {\n          continue;\n        }\n        var index = difference + 119;\n        if (ATTACKS[index] & PIECE_MASKS[piece.type]) {\n          if (piece.type === PAWN) {\n            if (difference > 0) {\n              if (piece.color === WHITE) return true;\n            } else {\n              if (piece.color === BLACK) return true;\n            }\n            continue;\n          }\n          // if the piece is a knight or a king\n          if (piece.type === 'n' || piece.type === 'k') return true;\n          var offset = RAYS[index];\n          var j = i + offset;\n          var blocked = false;\n          while (j !== square) {\n            if (this._board[j] != null) {\n              blocked = true;\n              break;\n            }\n            j += offset;\n          }\n          if (!blocked) return true;\n        }\n      }\n      return false;\n    }\n  }, {\n    key: \"_isKingAttacked\",\n    value: function _isKingAttacked(color) {\n      var square = this._kings[color];\n      return square === -1 ? false : this._attacked(swapColor(color), square);\n    }\n  }, {\n    key: \"isAttacked\",\n    value: function isAttacked(square, attackedBy) {\n      return this._attacked(attackedBy, Ox88[square]);\n    }\n  }, {\n    key: \"isCheck\",\n    value: function isCheck() {\n      return this._isKingAttacked(this._turn);\n    }\n  }, {\n    key: \"inCheck\",\n    value: function inCheck() {\n      return this.isCheck();\n    }\n  }, {\n    key: \"isCheckmate\",\n    value: function isCheckmate() {\n      return this.isCheck() && this._moves().length === 0;\n    }\n  }, {\n    key: \"isStalemate\",\n    value: function isStalemate() {\n      return !this.isCheck() && this._moves().length === 0;\n    }\n  }, {\n    key: \"isInsufficientMaterial\",\n    value: function isInsufficientMaterial() {\n      /*\n       * k.b. vs k.b. (of opposite colors) with mate in 1:\n       * 8/8/8/8/1b6/8/B1k5/K7 b - - 0 1\n       *\n       * k.b. vs k.n. with mate in 1:\n       * 8/8/8/8/1n6/8/B7/K1k5 b - - 2 1\n       */\n      var pieces = {\n        b: 0,\n        n: 0,\n        r: 0,\n        q: 0,\n        k: 0,\n        p: 0\n      };\n      var bishops = [];\n      var numPieces = 0;\n      var squareColor = 0;\n      for (var i = Ox88.a8; i <= Ox88.h1; i++) {\n        squareColor = (squareColor + 1) % 2;\n        if (i & 0x88) {\n          i += 7;\n          continue;\n        }\n        var piece = this._board[i];\n        if (piece) {\n          pieces[piece.type] = piece.type in pieces ? pieces[piece.type] + 1 : 1;\n          if (piece.type === BISHOP) {\n            bishops.push(squareColor);\n          }\n          numPieces++;\n        }\n      }\n      // k vs. k\n      if (numPieces === 2) {\n        return true;\n      } else if (\n      // k vs. kn .... or .... k vs. kb\n      numPieces === 3 && (pieces[BISHOP] === 1 || pieces[KNIGHT] === 1)) {\n        return true;\n      } else if (numPieces === pieces[BISHOP] + 2) {\n        // kb vs. kb where any number of bishops are all on the same color\n        var sum = 0;\n        var len = bishops.length;\n        for (var _i3 = 0; _i3 < len; _i3++) {\n          sum += bishops[_i3];\n        }\n        if (sum === 0 || sum === len) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }, {\n    key: \"isThreefoldRepetition\",\n    value: function isThreefoldRepetition() {\n      var moves = [];\n      var positions = {};\n      var repetition = false;\n      while (true) {\n        var move = this._undoMove();\n        if (!move) break;\n        moves.push(move);\n      }\n      while (true) {\n        /*\n         * remove the last two fields in the FEN string, they're not needed when\n         * checking for draw by rep\n         */\n        var fen = this.fen().split(' ').slice(0, 4).join(' ');\n        // has the position occurred three or move times\n        positions[fen] = fen in positions ? positions[fen] + 1 : 1;\n        if (positions[fen] >= 3) {\n          repetition = true;\n        }\n        var _move2 = moves.pop();\n        if (!_move2) {\n          break;\n        } else {\n          this._makeMove(_move2);\n        }\n      }\n      return repetition;\n    }\n  }, {\n    key: \"isDraw\",\n    value: function isDraw() {\n      return this._halfMoves >= 100 ||\n      // 50 moves per side = 100 half moves\n      this.isStalemate() || this.isInsufficientMaterial() || this.isThreefoldRepetition();\n    }\n  }, {\n    key: \"isGameOver\",\n    value: function isGameOver() {\n      return this.isCheckmate() || this.isStalemate() || this.isDraw();\n    }\n  }, {\n    key: \"moves\",\n    value: function moves() {\n      var _this2 = this;\n      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref2$verbose = _ref2.verbose,\n        verbose = _ref2$verbose === void 0 ? false : _ref2$verbose,\n        _ref2$square = _ref2.square,\n        square = _ref2$square === void 0 ? undefined : _ref2$square,\n        _ref2$piece = _ref2.piece,\n        piece = _ref2$piece === void 0 ? undefined : _ref2$piece;\n      var moves = this._moves({\n        square: square,\n        piece: piece\n      });\n      if (verbose) {\n        return moves.map(function (move) {\n          return _this2._makePretty(move);\n        });\n      } else {\n        return moves.map(function (move) {\n          return _this2._moveToSan(move, moves);\n        });\n      }\n    }\n  }, {\n    key: \"_moves\",\n    value: function _moves() {\n      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref3$legal = _ref3.legal,\n        legal = _ref3$legal === void 0 ? true : _ref3$legal,\n        _ref3$piece = _ref3.piece,\n        piece = _ref3$piece === void 0 ? undefined : _ref3$piece,\n        _ref3$square = _ref3.square,\n        square = _ref3$square === void 0 ? undefined : _ref3$square;\n      var forSquare = square ? square.toLowerCase() : undefined;\n      var forPiece = piece === null || piece === void 0 ? void 0 : piece.toLowerCase();\n      var moves = [];\n      var us = this._turn;\n      var them = swapColor(us);\n      var firstSquare = Ox88.a8;\n      var lastSquare = Ox88.h1;\n      var singleSquare = false;\n      // are we generating moves for a single square?\n      if (forSquare) {\n        // illegal square, return empty moves\n        if (!(forSquare in Ox88)) {\n          return [];\n        } else {\n          firstSquare = lastSquare = Ox88[forSquare];\n          singleSquare = true;\n        }\n      }\n      for (var from = firstSquare; from <= lastSquare; from++) {\n        // did we run off the end of the board\n        if (from & 0x88) {\n          from += 7;\n          continue;\n        }\n        // empty square or opponent, skip\n        if (!this._board[from] || this._board[from].color === them) {\n          continue;\n        }\n        var type = this._board[from].type;\n        var to = void 0;\n        if (type === PAWN) {\n          if (forPiece && forPiece !== type) continue;\n          // single square, non-capturing\n          to = from + PAWN_OFFSETS[us][0];\n          if (!this._board[to]) {\n            addMove(moves, us, from, to, PAWN);\n            // double square\n            to = from + PAWN_OFFSETS[us][1];\n            if (SECOND_RANK[us] === rank(from) && !this._board[to]) {\n              addMove(moves, us, from, to, PAWN, undefined, BITS.BIG_PAWN);\n            }\n          }\n          // pawn captures\n          for (var j = 2; j < 4; j++) {\n            var _this$_board$to;\n            to = from + PAWN_OFFSETS[us][j];\n            if (to & 0x88) continue;\n            if (((_this$_board$to = this._board[to]) === null || _this$_board$to === void 0 ? void 0 : _this$_board$to.color) === them) {\n              addMove(moves, us, from, to, PAWN, this._board[to].type, BITS.CAPTURE);\n            } else if (to === this._epSquare) {\n              addMove(moves, us, from, to, PAWN, PAWN, BITS.EP_CAPTURE);\n            }\n          }\n        } else {\n          if (forPiece && forPiece !== type) continue;\n          for (var _j = 0, len = PIECE_OFFSETS[type].length; _j < len; _j++) {\n            var offset = PIECE_OFFSETS[type][_j];\n            to = from;\n            while (true) {\n              to += offset;\n              if (to & 0x88) break;\n              if (!this._board[to]) {\n                addMove(moves, us, from, to, type);\n              } else {\n                // own color, stop loop\n                if (this._board[to].color === us) break;\n                addMove(moves, us, from, to, type, this._board[to].type, BITS.CAPTURE);\n                break;\n              }\n              /* break, if knight or king */\n              if (type === KNIGHT || type === KING) break;\n            }\n          }\n        }\n      }\n      /*\n       * check for castling if we're:\n       *   a) generating all moves, or\n       *   b) doing single square move generation on the king's square\n       */\n      if (forPiece === undefined || forPiece === KING) {\n        if (!singleSquare || lastSquare === this._kings[us]) {\n          // king-side castling\n          if (this._castling[us] & BITS.KSIDE_CASTLE) {\n            var castlingFrom = this._kings[us];\n            var castlingTo = castlingFrom + 2;\n            if (!this._board[castlingFrom + 1] && !this._board[castlingTo] && !this._attacked(them, this._kings[us]) && !this._attacked(them, castlingFrom + 1) && !this._attacked(them, castlingTo)) {\n              addMove(moves, us, this._kings[us], castlingTo, KING, undefined, BITS.KSIDE_CASTLE);\n            }\n          }\n          // queen-side castling\n          if (this._castling[us] & BITS.QSIDE_CASTLE) {\n            var _castlingFrom = this._kings[us];\n            var _castlingTo = _castlingFrom - 2;\n            if (!this._board[_castlingFrom - 1] && !this._board[_castlingFrom - 2] && !this._board[_castlingFrom - 3] && !this._attacked(them, this._kings[us]) && !this._attacked(them, _castlingFrom - 1) && !this._attacked(them, _castlingTo)) {\n              addMove(moves, us, this._kings[us], _castlingTo, KING, undefined, BITS.QSIDE_CASTLE);\n            }\n          }\n        }\n      }\n      /*\n       * return all pseudo-legal moves (this includes moves that allow the king\n       * to be captured)\n       */\n      if (!legal || this._kings[us] === -1) {\n        return moves;\n      }\n      // filter out illegal moves\n      var legalMoves = [];\n      for (var i = 0, _len = moves.length; i < _len; i++) {\n        this._makeMove(moves[i]);\n        if (!this._isKingAttacked(us)) {\n          legalMoves.push(moves[i]);\n        }\n        this._undoMove();\n      }\n      return legalMoves;\n    }\n  }, {\n    key: \"move\",\n    value: function move(_move) {\n      var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref4$strict = _ref4.strict,\n        strict = _ref4$strict === void 0 ? false : _ref4$strict;\n      /*\n       * The move function can be called with in the following parameters:\n       *\n       * .move('Nxb7')       <- argument is a case-sensitive SAN string\n       *\n       * .move({ from: 'h7', <- argument is a move object\n       *         to :'h8',\n       *         promotion: 'q' })\n       *\n       *\n       * An optional strict argument may be supplied to tell chess.js to\n       * strictly follow the SAN specification.\n       */\n      var moveObj = null;\n      if (typeof _move === 'string') {\n        moveObj = this._moveFromSan(_move, strict);\n      } else if (typeof _move === 'object') {\n        var moves = this._moves();\n        // convert the pretty move object to an ugly move object\n        for (var i = 0, len = moves.length; i < len; i++) {\n          if (_move.from === algebraic(moves[i].from) && _move.to === algebraic(moves[i].to) && (!('promotion' in moves[i]) || _move.promotion === moves[i].promotion)) {\n            moveObj = moves[i];\n            break;\n          }\n        }\n      }\n      // failed to find move\n      if (!moveObj) {\n        if (typeof _move === 'string') {\n          throw new Error(\"Invalid move: \".concat(_move));\n        } else {\n          throw new Error(\"Invalid move: \".concat(JSON.stringify(_move)));\n        }\n      }\n      /*\n       * need to make a copy of move because we can't generate SAN after the move\n       * is made\n       */\n      var prettyMove = this._makePretty(moveObj);\n      this._makeMove(moveObj);\n      return prettyMove;\n    }\n  }, {\n    key: \"_push\",\n    value: function _push(move) {\n      this._history.push({\n        move: move,\n        kings: {\n          b: this._kings.b,\n          w: this._kings.w\n        },\n        turn: this._turn,\n        castling: {\n          b: this._castling.b,\n          w: this._castling.w\n        },\n        epSquare: this._epSquare,\n        halfMoves: this._halfMoves,\n        moveNumber: this._moveNumber\n      });\n    }\n  }, {\n    key: \"_makeMove\",\n    value: function _makeMove(move) {\n      var us = this._turn;\n      var them = swapColor(us);\n      this._push(move);\n      this._board[move.to] = this._board[move.from];\n      delete this._board[move.from];\n      // if ep capture, remove the captured pawn\n      if (move.flags & BITS.EP_CAPTURE) {\n        if (this._turn === BLACK) {\n          delete this._board[move.to - 16];\n        } else {\n          delete this._board[move.to + 16];\n        }\n      }\n      // if pawn promotion, replace with new piece\n      if (move.promotion) {\n        this._board[move.to] = {\n          type: move.promotion,\n          color: us\n        };\n      }\n      // if we moved the king\n      if (this._board[move.to].type === KING) {\n        this._kings[us] = move.to;\n        // if we castled, move the rook next to the king\n        if (move.flags & BITS.KSIDE_CASTLE) {\n          var castlingTo = move.to - 1;\n          var castlingFrom = move.to + 1;\n          this._board[castlingTo] = this._board[castlingFrom];\n          delete this._board[castlingFrom];\n        } else if (move.flags & BITS.QSIDE_CASTLE) {\n          var _castlingTo2 = move.to + 1;\n          var _castlingFrom2 = move.to - 2;\n          this._board[_castlingTo2] = this._board[_castlingFrom2];\n          delete this._board[_castlingFrom2];\n        }\n        // turn off castling\n        this._castling[us] = 0;\n      }\n      // turn off castling if we move a rook\n      if (this._castling[us]) {\n        for (var i = 0, len = ROOKS[us].length; i < len; i++) {\n          if (move.from === ROOKS[us][i].square && this._castling[us] & ROOKS[us][i].flag) {\n            this._castling[us] ^= ROOKS[us][i].flag;\n            break;\n          }\n        }\n      }\n      // turn off castling if we capture a rook\n      if (this._castling[them]) {\n        for (var _i4 = 0, _len2 = ROOKS[them].length; _i4 < _len2; _i4++) {\n          if (move.to === ROOKS[them][_i4].square && this._castling[them] & ROOKS[them][_i4].flag) {\n            this._castling[them] ^= ROOKS[them][_i4].flag;\n            break;\n          }\n        }\n      }\n      // if big pawn move, update the en passant square\n      if (move.flags & BITS.BIG_PAWN) {\n        if (us === BLACK) {\n          this._epSquare = move.to - 16;\n        } else {\n          this._epSquare = move.to + 16;\n        }\n      } else {\n        this._epSquare = EMPTY;\n      }\n      // reset the 50 move counter if a pawn is moved or a piece is captured\n      if (move.piece === PAWN) {\n        this._halfMoves = 0;\n      } else if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n        this._halfMoves = 0;\n      } else {\n        this._halfMoves++;\n      }\n      if (us === BLACK) {\n        this._moveNumber++;\n      }\n      this._turn = them;\n    }\n  }, {\n    key: \"undo\",\n    value: function undo() {\n      var move = this._undoMove();\n      return move ? this._makePretty(move) : null;\n    }\n  }, {\n    key: \"_undoMove\",\n    value: function _undoMove() {\n      var old = this._history.pop();\n      if (old === undefined) {\n        return null;\n      }\n      var move = old.move;\n      this._kings = old.kings;\n      this._turn = old.turn;\n      this._castling = old.castling;\n      this._epSquare = old.epSquare;\n      this._halfMoves = old.halfMoves;\n      this._moveNumber = old.moveNumber;\n      var us = this._turn;\n      var them = swapColor(us);\n      this._board[move.from] = this._board[move.to];\n      this._board[move.from].type = move.piece; // to undo any promotions\n      delete this._board[move.to];\n      if (move.captured) {\n        if (move.flags & BITS.EP_CAPTURE) {\n          // en passant capture\n          var index;\n          if (us === BLACK) {\n            index = move.to - 16;\n          } else {\n            index = move.to + 16;\n          }\n          this._board[index] = {\n            type: PAWN,\n            color: them\n          };\n        } else {\n          // regular capture\n          this._board[move.to] = {\n            type: move.captured,\n            color: them\n          };\n        }\n      }\n      if (move.flags & (BITS.KSIDE_CASTLE | BITS.QSIDE_CASTLE)) {\n        var castlingTo, castlingFrom;\n        if (move.flags & BITS.KSIDE_CASTLE) {\n          castlingTo = move.to + 1;\n          castlingFrom = move.to - 1;\n        } else {\n          castlingTo = move.to - 2;\n          castlingFrom = move.to + 1;\n        }\n        this._board[castlingTo] = this._board[castlingFrom];\n        delete this._board[castlingFrom];\n      }\n      return move;\n    }\n  }, {\n    key: \"pgn\",\n    value: function pgn() {\n      var _this3 = this;\n      var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref5$newline = _ref5.newline,\n        newline = _ref5$newline === void 0 ? '\\n' : _ref5$newline,\n        _ref5$maxWidth = _ref5.maxWidth,\n        maxWidth = _ref5$maxWidth === void 0 ? 0 : _ref5$maxWidth;\n      /*\n       * using the specification from http://www.chessclub.com/help/PGN-spec\n       * example for html usage: .pgn({ max_width: 72, newline_char: \"<br />\" })\n       */\n      var result = [];\n      var headerExists = false;\n      /* add the PGN header information */\n      for (var i in this._header) {\n        /*\n         * TODO: order of enumerated properties in header object is not\n         * guaranteed, see ECMA-262 spec (section 12.6.4)\n         */\n        result.push('[' + i + ' \"' + this._header[i] + '\"]' + newline);\n        headerExists = true;\n      }\n      if (headerExists && this._history.length) {\n        result.push(newline);\n      }\n      var appendComment = function appendComment(moveString) {\n        var comment = _this3._comments[_this3.fen()];\n        if (typeof comment !== 'undefined') {\n          var delimiter = moveString.length > 0 ? ' ' : '';\n          moveString = \"\".concat(moveString).concat(delimiter, \"{\").concat(comment, \"}\");\n        }\n        return moveString;\n      };\n      // pop all of history onto reversed_history\n      var reversedHistory = [];\n      while (this._history.length > 0) {\n        reversedHistory.push(this._undoMove());\n      }\n      var moves = [];\n      var moveString = '';\n      // special case of a commented starting position with no moves\n      if (reversedHistory.length === 0) {\n        moves.push(appendComment(''));\n      }\n      // build the list of moves.  a move_string looks like: \"3. e3 e6\"\n      while (reversedHistory.length > 0) {\n        moveString = appendComment(moveString);\n        var move = reversedHistory.pop();\n        // make TypeScript stop complaining about move being undefined\n        if (!move) {\n          break;\n        }\n        // if the position started with black to move, start PGN with #. ...\n        if (!this._history.length && move.color === 'b') {\n          var prefix = \"\".concat(this._moveNumber, \". ...\");\n          // is there a comment preceding the first move?\n          moveString = moveString ? \"\".concat(moveString, \" \").concat(prefix) : prefix;\n        } else if (move.color === 'w') {\n          // store the previous generated move_string if we have one\n          if (moveString.length) {\n            moves.push(moveString);\n          }\n          moveString = this._moveNumber + '.';\n        }\n        moveString = moveString + ' ' + this._moveToSan(move, this._moves({\n          legal: true\n        }));\n        this._makeMove(move);\n      }\n      // are there any other leftover moves?\n      if (moveString.length) {\n        moves.push(appendComment(moveString));\n      }\n      // is there a result?\n      if (typeof this._header.Result !== 'undefined') {\n        moves.push(this._header.Result);\n      }\n      /*\n       * history should be back to what it was before we started generating PGN,\n       * so join together moves\n       */\n      if (maxWidth === 0) {\n        return result.join('') + moves.join(' ');\n      }\n      // TODO (jah): huh?\n      var strip = function strip() {\n        if (result.length > 0 && result[result.length - 1] === ' ') {\n          result.pop();\n          return true;\n        }\n        return false;\n      };\n      // NB: this does not preserve comment whitespace.\n      var wrapComment = function wrapComment(width, move) {\n        var _iterator = _createForOfIteratorHelper(move.split(' ')),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var token = _step.value;\n            if (!token) {\n              continue;\n            }\n            if (width + token.length > maxWidth) {\n              while (strip()) {\n                width--;\n              }\n              result.push(newline);\n              width = 0;\n            }\n            result.push(token);\n            width += token.length;\n            result.push(' ');\n            width++;\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n        if (strip()) {\n          width--;\n        }\n        return width;\n      };\n      // wrap the PGN output at max_width\n      var currentWidth = 0;\n      for (var _i5 = 0; _i5 < moves.length; _i5++) {\n        if (currentWidth + moves[_i5].length > maxWidth) {\n          if (moves[_i5].includes('{')) {\n            currentWidth = wrapComment(currentWidth, moves[_i5]);\n            continue;\n          }\n        }\n        // if the current move will push past max_width\n        if (currentWidth + moves[_i5].length > maxWidth && _i5 !== 0) {\n          // don't end the line with whitespace\n          if (result[result.length - 1] === ' ') {\n            result.pop();\n          }\n          result.push(newline);\n          currentWidth = 0;\n        } else if (_i5 !== 0) {\n          result.push(' ');\n          currentWidth++;\n        }\n        result.push(moves[_i5]);\n        currentWidth += moves[_i5].length;\n      }\n      return result.join('');\n    }\n  }, {\n    key: \"header\",\n    value: function header() {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key = 0; _key < _len3; _key++) {\n        args[_key] = arguments[_key];\n      }\n      for (var i = 0; i < args.length; i += 2) {\n        if (typeof args[i] === 'string' && typeof args[i + 1] === 'string') {\n          this._header[args[i]] = args[i + 1];\n        }\n      }\n      return this._header;\n    }\n  }, {\n    key: \"loadPgn\",\n    value: function loadPgn(pgn) {\n      var _ref6 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref6$strict = _ref6.strict,\n        strict = _ref6$strict === void 0 ? false : _ref6$strict,\n        _ref6$newlineChar = _ref6.newlineChar,\n        newlineChar = _ref6$newlineChar === void 0 ? '\\r?\\n' : _ref6$newlineChar;\n      function mask(str) {\n        return str.replace(/\\\\/g, '\\\\');\n      }\n      function parsePgnHeader(header) {\n        var headerObj = {};\n        var headers = header.split(new RegExp(mask(newlineChar)));\n        var key = '';\n        var value = '';\n        for (var i = 0; i < headers.length; i++) {\n          var regex = /^\\s*\\[\\s*([A-Za-z]+)\\s*\"(.*)\"\\s*\\]\\s*$/;\n          key = headers[i].replace(regex, '$1');\n          value = headers[i].replace(regex, '$2');\n          if (key.trim().length > 0) {\n            headerObj[key] = value;\n          }\n        }\n        return headerObj;\n      }\n      // strip whitespace from head/tail of PGN block\n      pgn = pgn.trim();\n      /*\n       * RegExp to split header. Takes advantage of the fact that header and movetext\n       * will always have a blank line between them (ie, two newline_char's). Handles\n       * case where movetext is empty by matching newlineChar until end of string is\n       * matched - effectively trimming from the end extra newlineChar.\n       *\n       * With default newline_char, will equal:\n       * /^(\\[((?:\\r?\\n)|.)*\\])((?:\\s*\\r?\\n){2}|(?:\\s*\\r?\\n)*$)/\n       */\n      var headerRegex = new RegExp('^(\\\\[((?:' + mask(newlineChar) + ')|.)*\\\\])' + '((?:\\\\s*' + mask(newlineChar) + '){2}|(?:\\\\s*' + mask(newlineChar) + ')*$)');\n      // If no header given, begin with moves.\n      var headerRegexResults = headerRegex.exec(pgn);\n      var headerString = headerRegexResults ? headerRegexResults.length >= 2 ? headerRegexResults[1] : '' : '';\n      // Put the board in the starting position\n      this.reset();\n      // parse PGN header\n      var headers = parsePgnHeader(headerString);\n      var fen = '';\n      for (var key in headers) {\n        // check to see user is including fen (possibly with wrong tag case)\n        if (key.toLowerCase() === 'fen') {\n          fen = headers[key];\n        }\n        this.header(key, headers[key]);\n      }\n      /*\n       * the permissive parser should attempt to load a fen tag, even if it's the\n       * wrong case and doesn't include a corresponding [SetUp \"1\"] tag\n       */\n      if (!strict) {\n        if (fen) {\n          this.load(fen, true);\n        }\n      } else {\n        /*\n         * strict parser - load the starting position indicated by [Setup '1']\n         * and [FEN position]\n         */\n        if (headers['SetUp'] === '1') {\n          if (!('FEN' in headers)) {\n            throw new Error('Invalid PGN: FEN tag must be supplied with SetUp tag');\n          }\n          // second argument to load: don't clear the headers\n          this.load(headers['FEN'], true);\n        }\n      }\n      /*\n       * NB: the regexes below that delete move numbers, recursive annotations,\n       * and numeric annotation glyphs may also match text in comments. To\n       * prevent this, we transform comments by hex-encoding them in place and\n       * decoding them again after the other tokens have been deleted.\n       *\n       * While the spec states that PGN files should be ASCII encoded, we use\n       * {en,de}codeURIComponent here to support arbitrary UTF8 as a convenience\n       * for modern users\n       */\n      function toHex(s) {\n        return Array.from(s).map(function (c) {\n          /*\n           * encodeURI doesn't transform most ASCII characters, so we handle\n           * these ourselves\n           */\n          return c.charCodeAt(0) < 128 ? c.charCodeAt(0).toString(16) : encodeURIComponent(c).replace(/%/g, '').toLowerCase();\n        }).join('');\n      }\n      function fromHex(s) {\n        return s.length == 0 ? '' : decodeURIComponent('%' + (s.match(/.{1,2}/g) || []).join('%'));\n      }\n      var encodeComment = function encodeComment(s) {\n        s = s.replace(new RegExp(mask(newlineChar), 'g'), ' ');\n        return \"{\".concat(toHex(s.slice(1, s.length - 1)), \"}\");\n      };\n      var decodeComment = function decodeComment(s) {\n        if (s.startsWith('{') && s.endsWith('}')) {\n          return fromHex(s.slice(1, s.length - 1));\n        }\n      };\n      // delete header to get the moves\n      var ms = pgn.replace(headerString, '').replace(\n      // encode comments so they don't get deleted below\n      new RegExp(\"({[^}]*})+?|;([^\".concat(mask(newlineChar), \"]*)\"), 'g'), function (_match, bracket, semicolon) {\n        return bracket !== undefined ? encodeComment(bracket) : ' ' + encodeComment(\"{\".concat(semicolon.slice(1), \"}\"));\n      }).replace(new RegExp(mask(newlineChar), 'g'), ' ');\n      // delete recursive annotation variations\n      var ravRegex = /(\\([^()]+\\))+?/g;\n      while (ravRegex.test(ms)) {\n        ms = ms.replace(ravRegex, '');\n      }\n      // delete move numbers\n      ms = ms.replace(/\\d+\\.(\\.\\.)?/g, '');\n      // delete ... indicating black to move\n      ms = ms.replace(/\\.\\.\\./g, '');\n      /* delete numeric annotation glyphs */\n      ms = ms.replace(/\\$\\d+/g, '');\n      // trim and get array of moves\n      var moves = ms.trim().split(new RegExp(/\\s+/));\n      // delete empty entries\n      moves = moves.filter(function (move) {\n        return move !== '';\n      });\n      var result = '';\n      for (var halfMove = 0; halfMove < moves.length; halfMove++) {\n        var comment = decodeComment(moves[halfMove]);\n        if (comment !== undefined) {\n          this._comments[this.fen()] = comment;\n          continue;\n        }\n        var move = this._moveFromSan(moves[halfMove], strict);\n        // invalid move\n        if (move == null) {\n          // was the move an end of game marker\n          if (TERMINATION_MARKERS.indexOf(moves[halfMove]) > -1) {\n            result = moves[halfMove];\n          } else {\n            throw new Error(\"Invalid move in PGN: \".concat(moves[halfMove]));\n          }\n        } else {\n          // reset the end of game marker if making a valid move\n          result = '';\n          this._makeMove(move);\n        }\n      }\n      /*\n       * Per section 8.2.6 of the PGN spec, the Result tag pair must match match\n       * the termination marker. Only do this when headers are present, but the\n       * result tag is missing\n       */\n      if (result && Object.keys(this._header).length && !this._header['Result']) {\n        this.header('Result', result);\n      }\n    }\n    /*\n     * Convert a move from 0x88 coordinates to Standard Algebraic Notation\n     * (SAN)\n     *\n     * @param {boolean} strict Use the strict SAN parser. It will throw errors\n     * on overly disambiguated moves (see below):\n     *\n     * r1bqkbnr/ppp2ppp/2n5/1B1pP3/4P3/8/PPPP2PP/RNBQK1NR b KQkq - 2 4\n     * 4. ... Nge7 is overly disambiguated because the knight on c6 is pinned\n     * 4. ... Ne7 is technically the valid SAN\n     */\n  }, {\n    key: \"_moveToSan\",\n    value: function _moveToSan(move, moves) {\n      var output = '';\n      if (move.flags & BITS.KSIDE_CASTLE) {\n        output = 'O-O';\n      } else if (move.flags & BITS.QSIDE_CASTLE) {\n        output = 'O-O-O';\n      } else {\n        if (move.piece !== PAWN) {\n          var disambiguator = getDisambiguator(move, moves);\n          output += move.piece.toUpperCase() + disambiguator;\n        }\n        if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n          if (move.piece === PAWN) {\n            output += algebraic(move.from)[0];\n          }\n          output += 'x';\n        }\n        output += algebraic(move.to);\n        if (move.promotion) {\n          output += '=' + move.promotion.toUpperCase();\n        }\n      }\n      this._makeMove(move);\n      if (this.isCheck()) {\n        if (this.isCheckmate()) {\n          output += '#';\n        } else {\n          output += '+';\n        }\n      }\n      this._undoMove();\n      return output;\n    }\n    // convert a move from Standard Algebraic Notation (SAN) to 0x88 coordinates\n  }, {\n    key: \"_moveFromSan\",\n    value: function _moveFromSan(move) {\n      var strict = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      // strip off any move decorations: e.g Nf3+?! becomes Nf3\n      var cleanMove = strippedSan(move);\n      var pieceType = inferPieceType(cleanMove);\n      var moves = this._moves({\n        legal: true,\n        piece: pieceType\n      });\n      // strict parser\n      for (var i = 0, len = moves.length; i < len; i++) {\n        if (cleanMove === strippedSan(this._moveToSan(moves[i], moves))) {\n          return moves[i];\n        }\n      }\n      // the strict parser failed\n      if (strict) {\n        return null;\n      }\n      var piece = undefined;\n      var matches = undefined;\n      var from = undefined;\n      var to = undefined;\n      var promotion = undefined;\n      /*\n       * The default permissive (non-strict) parser allows the user to parse\n       * non-standard chess notations. This parser is only run after the strict\n       * Standard Algebraic Notation (SAN) parser has failed.\n       *\n       * When running the permissive parser, we'll run a regex to grab the piece, the\n       * to/from square, and an optional promotion piece. This regex will\n       * parse common non-standard notation like: Pe2-e4, Rc1c4, Qf3xf7,\n       * f7f8q, b1c3\n       *\n       * NOTE: Some positions and moves may be ambiguous when using the permissive\n       * parser. For example, in this position: 6k1/8/8/B7/8/8/8/BN4K1 w - - 0 1,\n       * the move b1c3 may be interpreted as Nc3 or B1c3 (a disambiguated bishop\n       * move). In these cases, the permissive parser will default to the most\n       * basic interpretation (which is b1c3 parsing to Nc3).\n       */\n      var overlyDisambiguated = false;\n      matches = cleanMove.match(/([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/\n      //     piece         from              to       promotion\n      );\n\n      if (matches) {\n        piece = matches[1];\n        from = matches[2];\n        to = matches[3];\n        promotion = matches[4];\n        if (from.length == 1) {\n          overlyDisambiguated = true;\n        }\n      } else {\n        /*\n         * The [a-h]?[1-8]? portion of the regex below handles moves that may be\n         * overly disambiguated (e.g. Nge7 is unnecessary and non-standard when\n         * there is one legal knight move to e7). In this case, the value of\n         * 'from' variable will be a rank or file, not a square.\n         */\n        matches = cleanMove.match(/([pnbrqkPNBRQK])?([a-h]?[1-8]?)x?-?([a-h][1-8])([qrbnQRBN])?/);\n        if (matches) {\n          piece = matches[1];\n          from = matches[2];\n          to = matches[3];\n          promotion = matches[4];\n          if (from.length == 1) {\n            overlyDisambiguated = true;\n          }\n        }\n      }\n      pieceType = inferPieceType(cleanMove);\n      moves = this._moves({\n        legal: true,\n        piece: piece ? piece : pieceType\n      });\n      if (!to) {\n        return null;\n      }\n      for (var _i6 = 0, _len4 = moves.length; _i6 < _len4; _i6++) {\n        if (!from) {\n          // if there is no from square, it could be just 'x' missing from a capture\n          if (cleanMove === strippedSan(this._moveToSan(moves[_i6], moves)).replace('x', '')) {\n            return moves[_i6];\n          }\n          // hand-compare move properties with the results from our permissive regex\n        } else if ((!piece || piece.toLowerCase() == moves[_i6].piece) && Ox88[from] == moves[_i6].from && Ox88[to] == moves[_i6].to && (!promotion || promotion.toLowerCase() == moves[_i6].promotion)) {\n          return moves[_i6];\n        } else if (overlyDisambiguated) {\n          /*\n           * SPECIAL CASE: we parsed a move string that may have an unneeded\n           * rank/file disambiguator (e.g. Nge7).  The 'from' variable will\n           */\n          var square = algebraic(moves[_i6].from);\n          if ((!piece || piece.toLowerCase() == moves[_i6].piece) && Ox88[to] == moves[_i6].to && (from == square[0] || from == square[1]) && (!promotion || promotion.toLowerCase() == moves[_i6].promotion)) {\n            return moves[_i6];\n          }\n        }\n      }\n      return null;\n    }\n  }, {\n    key: \"ascii\",\n    value: function ascii() {\n      var s = '   +------------------------+\\n';\n      for (var i = Ox88.a8; i <= Ox88.h1; i++) {\n        // display the rank\n        if (file(i) === 0) {\n          s += ' ' + '87654321'[rank(i)] + ' |';\n        }\n        if (this._board[i]) {\n          var piece = this._board[i].type;\n          var color = this._board[i].color;\n          var symbol = color === WHITE ? piece.toUpperCase() : piece.toLowerCase();\n          s += ' ' + symbol + ' ';\n        } else {\n          s += ' . ';\n        }\n        if (i + 1 & 0x88) {\n          s += '|\\n';\n          i += 8;\n        }\n      }\n      s += '   +------------------------+\\n';\n      s += '     a  b  c  d  e  f  g  h';\n      return s;\n    }\n  }, {\n    key: \"perft\",\n    value: function perft(depth) {\n      var moves = this._moves({\n        legal: false\n      });\n      var nodes = 0;\n      var color = this._turn;\n      for (var i = 0, len = moves.length; i < len; i++) {\n        this._makeMove(moves[i]);\n        if (!this._isKingAttacked(color)) {\n          if (depth - 1 > 0) {\n            nodes += this.perft(depth - 1);\n          } else {\n            nodes++;\n          }\n        }\n        this._undoMove();\n      }\n      return nodes;\n    }\n    // pretty = external move object\n  }, {\n    key: \"_makePretty\",\n    value: function _makePretty(uglyMove) {\n      var color = uglyMove.color,\n        piece = uglyMove.piece,\n        from = uglyMove.from,\n        to = uglyMove.to,\n        flags = uglyMove.flags,\n        captured = uglyMove.captured,\n        promotion = uglyMove.promotion;\n      var prettyFlags = '';\n      for (var flag in BITS) {\n        if (BITS[flag] & flags) {\n          prettyFlags += FLAGS[flag];\n        }\n      }\n      var fromAlgebraic = algebraic(from);\n      var toAlgebraic = algebraic(to);\n      var move = {\n        color: color,\n        piece: piece,\n        from: fromAlgebraic,\n        to: toAlgebraic,\n        san: this._moveToSan(uglyMove, this._moves({\n          legal: true\n        })),\n        flags: prettyFlags,\n        lan: fromAlgebraic + toAlgebraic,\n        before: this.fen(),\n        after: ''\n      };\n      // generate the FEN for the 'after' key\n      this._makeMove(uglyMove);\n      move.after = this.fen();\n      this._undoMove();\n      if (captured) {\n        move.captured = captured;\n      }\n      if (promotion) {\n        move.promotion = promotion;\n        move.lan += promotion;\n      }\n      return move;\n    }\n  }, {\n    key: \"turn\",\n    value: function turn() {\n      return this._turn;\n    }\n  }, {\n    key: \"board\",\n    value: function board() {\n      var output = [];\n      var row = [];\n      for (var i = Ox88.a8; i <= Ox88.h1; i++) {\n        if (this._board[i] == null) {\n          row.push(null);\n        } else {\n          row.push({\n            square: algebraic(i),\n            type: this._board[i].type,\n            color: this._board[i].color\n          });\n        }\n        if (i + 1 & 0x88) {\n          output.push(row);\n          row = [];\n          i += 8;\n        }\n      }\n      return output;\n    }\n  }, {\n    key: \"squareColor\",\n    value: function squareColor(square) {\n      if (square in Ox88) {\n        var sq = Ox88[square];\n        return (rank(sq) + file(sq)) % 2 === 0 ? 'light' : 'dark';\n      }\n      return null;\n    }\n  }, {\n    key: \"history\",\n    value: function history() {\n      var _ref7 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref7$verbose = _ref7.verbose,\n        verbose = _ref7$verbose === void 0 ? false : _ref7$verbose;\n      var reversedHistory = [];\n      var moveHistory = [];\n      while (this._history.length > 0) {\n        reversedHistory.push(this._undoMove());\n      }\n      while (true) {\n        var move = reversedHistory.pop();\n        if (!move) {\n          break;\n        }\n        if (verbose) {\n          moveHistory.push(this._makePretty(move));\n        } else {\n          moveHistory.push(this._moveToSan(move, this._moves()));\n        }\n        this._makeMove(move);\n      }\n      return moveHistory;\n    }\n  }, {\n    key: \"_pruneComments\",\n    value: function _pruneComments() {\n      var _this4 = this;\n      var reversedHistory = [];\n      var currentComments = {};\n      var copyComment = function copyComment(fen) {\n        if (fen in _this4._comments) {\n          currentComments[fen] = _this4._comments[fen];\n        }\n      };\n      while (this._history.length > 0) {\n        reversedHistory.push(this._undoMove());\n      }\n      copyComment(this.fen());\n      while (true) {\n        var move = reversedHistory.pop();\n        if (!move) {\n          break;\n        }\n        this._makeMove(move);\n        copyComment(this.fen());\n      }\n      this._comments = currentComments;\n    }\n  }, {\n    key: \"getComment\",\n    value: function getComment() {\n      return this._comments[this.fen()];\n    }\n  }, {\n    key: \"setComment\",\n    value: function setComment(comment) {\n      this._comments[this.fen()] = comment.replace('{', '[').replace('}', ']');\n    }\n  }, {\n    key: \"deleteComment\",\n    value: function deleteComment() {\n      var comment = this._comments[this.fen()];\n      delete this._comments[this.fen()];\n      return comment;\n    }\n  }, {\n    key: \"getComments\",\n    value: function getComments() {\n      var _this5 = this;\n      this._pruneComments();\n      return Object.keys(this._comments).map(function (fen) {\n        return {\n          fen: fen,\n          comment: _this5._comments[fen]\n        };\n      });\n    }\n  }, {\n    key: \"deleteComments\",\n    value: function deleteComments() {\n      var _this6 = this;\n      this._pruneComments();\n      return Object.keys(this._comments).map(function (fen) {\n        var comment = _this6._comments[fen];\n        delete _this6._comments[fen];\n        return {\n          fen: fen,\n          comment: comment\n        };\n      });\n    }\n  }, {\n    key: \"setCastlingRights\",\n    value: function setCastlingRights(color, rights) {\n      for (var _i7 = 0, _arr = [KING, QUEEN]; _i7 < _arr.length; _i7++) {\n        var side = _arr[_i7];\n        if (rights[side] !== undefined) {\n          if (rights[side]) {\n            this._castling[color] |= SIDES[side];\n          } else {\n            this._castling[color] &= ~SIDES[side];\n          }\n        }\n      }\n      this._updateCastlingRights();\n      var result = this.getCastlingRights(color);\n      return (rights[KING] === undefined || rights[KING] === result[KING]) && (rights[QUEEN] === undefined || rights[QUEEN] === result[QUEEN]);\n    }\n  }, {\n    key: \"getCastlingRights\",\n    value: function getCastlingRights(color) {\n      var _ref8;\n      return _ref8 = {}, _defineProperty(_ref8, KING, (this._castling[color] & SIDES[KING]) !== 0), _defineProperty(_ref8, QUEEN, (this._castling[color] & SIDES[QUEEN]) !== 0), _ref8;\n    }\n  }, {\n    key: \"moveNumber\",\n    value: function moveNumber() {\n      return this._moveNumber;\n    }\n  }]);\n  return Chess;\n}();","map":{"version":3,"names":["WHITE","BLACK","PAWN","KNIGHT","BISHOP","ROOK","QUEEN","KING","DEFAULT_POSITION","EMPTY","FLAGS","NORMAL","CAPTURE","BIG_PAWN","EP_CAPTURE","PROMOTION","KSIDE_CASTLE","QSIDE_CASTLE","SQUARES","BITS","Ox88","a8","b8","c8","d8","e8","f8","g8","h8","a7","b7","c7","d7","e7","f7","g7","h7","a6","b6","c6","d6","e6","f6","g6","h6","a5","b5","c5","d5","e5","f5","g5","h5","a4","b4","c4","d4","e4","f4","g4","h4","a3","b3","c3","d3","e3","f3","g3","h3","a2","b2","c2","d2","e2","f2","g2","h2","a1","b1","c1","d1","e1","f1","g1","h1","PAWN_OFFSETS","b","w","PIECE_OFFSETS","n","r","q","k","ATTACKS","RAYS","PIECE_MASKS","p","SYMBOLS","PROMOTIONS","RANK_1","RANK_2","RANK_7","RANK_8","SIDES","_SIDES","_defineProperty","ROOKS","square","flag","SECOND_RANK","TERMINATION_MARKERS","rank","file","isDigit","c","indexOf","algebraic","f","substring","swapColor","color","validateFen","fen","tokens","split","length","ok","error","moveNumber","parseInt","isNaN","halfMoves","test","rows","i","sumFields","previousWasNumber","kings","regex","_i","_kings","_kings$_i","concat","match","getDisambiguator","move","moves","from","to","piece","ambiguities","sameRank","sameFile","len","ambigFrom","ambigTo","ambigPiece","charAt","addMove","captured","arguments","undefined","flags","promotion","push","inferPieceType","san","pieceType","matches","toLowerCase","strippedSan","replace","Chess","_classCallCheck","Array","load","_createClass","key","value","clear","keepHeaders","_board","_turn","_castling","_epSquare","_halfMoves","_moveNumber","_history","_comments","_header","_updateSetup","removeHeader","adjustments","slice","join","_validateFen","Error","position","put","type","empty","_this$_board$i","toUpperCase","castling","epSquare","bigPawnSquare","squares","_i2","_squares","_this$_board$square","_this$_board$square2","_makeMove","isLegal","_isKingAttacked","_undoMove","reset","get","_ref","sq","_updateCastlingRights","_updateEnPassantSquare","remove","_this$_board$Ox88$e","_this$_board$Ox88$e2","_this$_board$Ox88$e3","_this$_board$Ox88$e4","_this$_board$Ox88$a","_this$_board$Ox88$a2","_this$_board$Ox88$h","_this$_board$Ox88$h2","_this$_board$Ox88$a3","_this$_board$Ox88$a4","_this$_board$Ox88$h3","_this$_board$Ox88$h4","whiteKingInPlace","blackKingInPlace","_this$_board$currentS","_this$_board$currentS2","_this","startSquare","currentSquare","attackers","canCapture","_this$_board$square3","_this$_board$square4","some","_attacked","difference","index","offset","j","blocked","isAttacked","attackedBy","isCheck","inCheck","isCheckmate","_moves","isStalemate","isInsufficientMaterial","pieces","bishops","numPieces","squareColor","sum","isThreefoldRepetition","positions","repetition","pop","isDraw","isGameOver","_this2","_ref2","_ref2$verbose","verbose","_ref2$square","_ref2$piece","map","_makePretty","_moveToSan","_ref3","_ref3$legal","legal","_ref3$piece","_ref3$square","forSquare","forPiece","us","them","firstSquare","lastSquare","singleSquare","_this$_board$to","castlingFrom","castlingTo","legalMoves","_ref4","_ref4$strict","strict","moveObj","_moveFromSan","JSON","stringify","prettyMove","_push","turn","undo","old","pgn","_this3","_ref5","_ref5$newline","newline","_ref5$maxWidth","maxWidth","result","headerExists","appendComment","moveString","comment","delimiter","reversedHistory","prefix","Result","strip","wrapComment","width","_iterator","_createForOfIteratorHelper","_step","s","done","token","err","e","currentWidth","includes","header","_len3","args","_key","loadPgn","_ref6","_ref6$strict","_ref6$newlineChar","newlineChar","mask","str","parsePgnHeader","headerObj","headers","RegExp","trim","headerRegex","headerRegexResults","exec","headerString","toHex","charCodeAt","toString","encodeURIComponent","fromHex","decodeURIComponent","encodeComment","decodeComment","startsWith","endsWith","ms","_match","bracket","semicolon","ravRegex","filter","halfMove","Object","keys","output","disambiguator","cleanMove","overlyDisambiguated","ascii","symbol","perft","depth","nodes","uglyMove","prettyFlags","fromAlgebraic","toAlgebraic","lan","before","after","board","row","history","_ref7","_ref7$verbose","moveHistory","_pruneComments","_this4","currentComments","copyComment","getComment","setComment","deleteComment","getComments","_this5","deleteComments","_this6","setCastlingRights","rights","_i7","_arr","side","getCastlingRights","_ref8"],"sources":["/root/code/amandaaurora/chess-pgn-react/node_modules/chess.js/src/chess.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) 2023, Jeff Hlywa (jhlywa@gmail.com)\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\nexport const WHITE = 'w'\nexport const BLACK = 'b'\n\nexport const PAWN = 'p'\nexport const KNIGHT = 'n'\nexport const BISHOP = 'b'\nexport const ROOK = 'r'\nexport const QUEEN = 'q'\nexport const KING = 'k'\n\nexport type Color = 'w' | 'b'\nexport type PieceSymbol = 'p' | 'n' | 'b' | 'r' | 'q' | 'k'\n\n// prettier-ignore\nexport type Square =\n    'a8' | 'b8' | 'c8' | 'd8' | 'e8' | 'f8' | 'g8' | 'h8' |\n    'a7' | 'b7' | 'c7' | 'd7' | 'e7' | 'f7' | 'g7' | 'h7' |\n    'a6' | 'b6' | 'c6' | 'd6' | 'e6' | 'f6' | 'g6' | 'h6' |\n    'a5' | 'b5' | 'c5' | 'd5' | 'e5' | 'f5' | 'g5' | 'h5' |\n    'a4' | 'b4' | 'c4' | 'd4' | 'e4' | 'f4' | 'g4' | 'h4' |\n    'a3' | 'b3' | 'c3' | 'd3' | 'e3' | 'f3' | 'g3' | 'h3' |\n    'a2' | 'b2' | 'c2' | 'd2' | 'e2' | 'f2' | 'g2' | 'h2' |\n    'a1' | 'b1' | 'c1' | 'd1' | 'e1' | 'f1' | 'g1' | 'h1'\n\nexport const DEFAULT_POSITION =\n  'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1'\n\nexport type Piece = {\n  color: Color\n  type: PieceSymbol\n}\n\ntype InternalMove = {\n  color: Color\n  from: number\n  to: number\n  piece: PieceSymbol\n  captured?: PieceSymbol\n  promotion?: PieceSymbol\n  flags: number\n}\n\ninterface History {\n  move: InternalMove\n  kings: Record<Color, number>\n  turn: Color\n  castling: Record<Color, number>\n  epSquare: number\n  halfMoves: number\n  moveNumber: number\n}\n\nexport type Move = {\n  color: Color\n  from: Square\n  to: Square\n  piece: PieceSymbol\n  captured?: PieceSymbol\n  promotion?: PieceSymbol\n  flags: string\n  san: string\n  lan: string\n  before: string\n  after: string\n}\n\nconst EMPTY = -1\n\nconst FLAGS: Record<string, string> = {\n  NORMAL: 'n',\n  CAPTURE: 'c',\n  BIG_PAWN: 'b',\n  EP_CAPTURE: 'e',\n  PROMOTION: 'p',\n  KSIDE_CASTLE: 'k',\n  QSIDE_CASTLE: 'q',\n}\n\n// prettier-ignore\nexport const SQUARES: Square[] = [\n  'a8', 'b8', 'c8', 'd8', 'e8', 'f8', 'g8', 'h8',\n  'a7', 'b7', 'c7', 'd7', 'e7', 'f7', 'g7', 'h7',\n  'a6', 'b6', 'c6', 'd6', 'e6', 'f6', 'g6', 'h6',\n  'a5', 'b5', 'c5', 'd5', 'e5', 'f5', 'g5', 'h5',\n  'a4', 'b4', 'c4', 'd4', 'e4', 'f4', 'g4', 'h4',\n  'a3', 'b3', 'c3', 'd3', 'e3', 'f3', 'g3', 'h3',\n  'a2', 'b2', 'c2', 'd2', 'e2', 'f2', 'g2', 'h2',\n  'a1', 'b1', 'c1', 'd1', 'e1', 'f1', 'g1', 'h1'\n]\n\nconst BITS: Record<string, number> = {\n  NORMAL: 1,\n  CAPTURE: 2,\n  BIG_PAWN: 4,\n  EP_CAPTURE: 8,\n  PROMOTION: 16,\n  KSIDE_CASTLE: 32,\n  QSIDE_CASTLE: 64,\n}\n\n/*\n * NOTES ABOUT 0x88 MOVE GENERATION ALGORITHM\n * ----------------------------------------------------------------------------\n * From https://github.com/jhlywa/chess.js/issues/230\n *\n * A lot of people are confused when they first see the internal representation\n * of chess.js. It uses the 0x88 Move Generation Algorithm which internally\n * stores the board as an 8x16 array. This is purely for efficiency but has a\n * couple of interesting benefits:\n *\n * 1. 0x88 offers a very inexpensive \"off the board\" check. Bitwise AND (&) any\n *    square with 0x88, if the result is non-zero then the square is off the\n *    board. For example, assuming a knight square A8 (0 in 0x88 notation),\n *    there are 8 possible directions in which the knight can move. These\n *    directions are relative to the 8x16 board and are stored in the\n *    PIECE_OFFSETS map. One possible move is A8 - 18 (up one square, and two\n *    squares to the left - which is off the board). 0 - 18 = -18 & 0x88 = 0x88\n *    (because of two-complement representation of -18). The non-zero result\n *    means the square is off the board and the move is illegal. Take the\n *    opposite move (from A8 to C7), 0 + 18 = 18 & 0x88 = 0. A result of zero\n *    means the square is on the board.\n *\n * 2. The relative distance (or difference) between two squares on a 8x16 board\n *    is unique and can be used to inexpensively determine if a piece on a\n *    square can attack any other arbitrary square. For example, let's see if a\n *    pawn on E7 can attack E2. The difference between E7 (20) - E2 (100) is\n *    -80. We add 119 to make the ATTACKS array index non-negative (because the\n *    worst case difference is A8 - H1 = -119). The ATTACKS array contains a\n *    bitmask of pieces that can attack from that distance and direction.\n *    ATTACKS[-80 + 119=39] gives us 24 or 0b11000 in binary. Look at the\n *    PIECE_MASKS map to determine the mask for a given piece type. In our pawn\n *    example, we would check to see if 24 & 0x1 is non-zero, which it is\n *    not. So, naturally, a pawn on E7 can't attack a piece on E2. However, a\n *    rook can since 24 & 0x8 is non-zero. The only thing left to check is that\n *    there are no blocking pieces between E7 and E2. That's where the RAYS\n *    array comes in. It provides an offset (in this case 16) to add to E7 (20)\n *    to check for blocking pieces. E7 (20) + 16 = E6 (36) + 16 = E5 (52) etc.\n */\n\n// prettier-ignore\n// eslint-disable-next-line\nconst Ox88: Record<Square, number> = {\n  a8:   0, b8:   1, c8:   2, d8:   3, e8:   4, f8:   5, g8:   6, h8:   7,\n  a7:  16, b7:  17, c7:  18, d7:  19, e7:  20, f7:  21, g7:  22, h7:  23,\n  a6:  32, b6:  33, c6:  34, d6:  35, e6:  36, f6:  37, g6:  38, h6:  39,\n  a5:  48, b5:  49, c5:  50, d5:  51, e5:  52, f5:  53, g5:  54, h5:  55,\n  a4:  64, b4:  65, c4:  66, d4:  67, e4:  68, f4:  69, g4:  70, h4:  71,\n  a3:  80, b3:  81, c3:  82, d3:  83, e3:  84, f3:  85, g3:  86, h3:  87,\n  a2:  96, b2:  97, c2:  98, d2:  99, e2: 100, f2: 101, g2: 102, h2: 103,\n  a1: 112, b1: 113, c1: 114, d1: 115, e1: 116, f1: 117, g1: 118, h1: 119\n}\n\nconst PAWN_OFFSETS = {\n  b: [16, 32, 17, 15],\n  w: [-16, -32, -17, -15],\n}\n\nconst PIECE_OFFSETS = {\n  n: [-18, -33, -31, -14, 18, 33, 31, 14],\n  b: [-17, -15, 17, 15],\n  r: [-16, 1, 16, -1],\n  q: [-17, -16, -15, 1, 17, 16, 15, -1],\n  k: [-17, -16, -15, 1, 17, 16, 15, -1],\n}\n\n// prettier-ignore\nconst ATTACKS = [\n  20, 0, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0, 0,20, 0,\n   0,20, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0,20, 0, 0,\n   0, 0,20, 0, 0, 0, 0, 24,  0, 0, 0, 0,20, 0, 0, 0,\n   0, 0, 0,20, 0, 0, 0, 24,  0, 0, 0,20, 0, 0, 0, 0,\n   0, 0, 0, 0,20, 0, 0, 24,  0, 0,20, 0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,20, 2, 24,  2,20, 0, 0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0, 2,53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\n  24,24,24,24,24,24,56,  0, 56,24,24,24,24,24,24, 0,\n   0, 0, 0, 0, 0, 2,53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,20, 2, 24,  2,20, 0, 0, 0, 0, 0, 0,\n   0, 0, 0, 0,20, 0, 0, 24,  0, 0,20, 0, 0, 0, 0, 0,\n   0, 0, 0,20, 0, 0, 0, 24,  0, 0, 0,20, 0, 0, 0, 0,\n   0, 0,20, 0, 0, 0, 0, 24,  0, 0, 0, 0,20, 0, 0, 0,\n   0,20, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0,20, 0, 0,\n  20, 0, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0, 0,20\n];\n\n// prettier-ignore\nconst RAYS = [\n   17,  0,  0,  0,  0,  0,  0, 16,  0,  0,  0,  0,  0,  0, 15, 0,\n    0, 17,  0,  0,  0,  0,  0, 16,  0,  0,  0,  0,  0, 15,  0, 0,\n    0,  0, 17,  0,  0,  0,  0, 16,  0,  0,  0,  0, 15,  0,  0, 0,\n    0,  0,  0, 17,  0,  0,  0, 16,  0,  0,  0, 15,  0,  0,  0, 0,\n    0,  0,  0,  0, 17,  0,  0, 16,  0,  0, 15,  0,  0,  0,  0, 0,\n    0,  0,  0,  0,  0, 17,  0, 16,  0, 15,  0,  0,  0,  0,  0, 0,\n    0,  0,  0,  0,  0,  0, 17, 16, 15,  0,  0,  0,  0,  0,  0, 0,\n    1,  1,  1,  1,  1,  1,  1,  0, -1, -1,  -1,-1, -1, -1, -1, 0,\n    0,  0,  0,  0,  0,  0,-15,-16,-17,  0,  0,  0,  0,  0,  0, 0,\n    0,  0,  0,  0,  0,-15,  0,-16,  0,-17,  0,  0,  0,  0,  0, 0,\n    0,  0,  0,  0,-15,  0,  0,-16,  0,  0,-17,  0,  0,  0,  0, 0,\n    0,  0,  0,-15,  0,  0,  0,-16,  0,  0,  0,-17,  0,  0,  0, 0,\n    0,  0,-15,  0,  0,  0,  0,-16,  0,  0,  0,  0,-17,  0,  0, 0,\n    0,-15,  0,  0,  0,  0,  0,-16,  0,  0,  0,  0,  0,-17,  0, 0,\n  -15,  0,  0,  0,  0,  0,  0,-16,  0,  0,  0,  0,  0,  0,-17\n];\n\nconst PIECE_MASKS = { p: 0x1, n: 0x2, b: 0x4, r: 0x8, q: 0x10, k: 0x20 }\n\nconst SYMBOLS = 'pnbrqkPNBRQK'\n\nconst PROMOTIONS: PieceSymbol[] = [KNIGHT, BISHOP, ROOK, QUEEN]\n\nconst RANK_1 = 7\nconst RANK_2 = 6\n/*\n * const RANK_3 = 5\n * const RANK_4 = 4\n * const RANK_5 = 3\n * const RANK_6 = 2\n */\nconst RANK_7 = 1\nconst RANK_8 = 0\n\nconst SIDES = {\n  [KING]: BITS.KSIDE_CASTLE,\n  [QUEEN]: BITS.QSIDE_CASTLE\n}\n\nconst ROOKS = {\n  w: [\n    { square: Ox88.a1, flag: BITS.QSIDE_CASTLE },\n    { square: Ox88.h1, flag: BITS.KSIDE_CASTLE },\n  ],\n  b: [\n    { square: Ox88.a8, flag: BITS.QSIDE_CASTLE },\n    { square: Ox88.h8, flag: BITS.KSIDE_CASTLE },\n  ],\n}\n\nconst SECOND_RANK = { b: RANK_7, w: RANK_2 }\n\nconst TERMINATION_MARKERS = ['1-0', '0-1', '1/2-1/2', '*']\n\n// Extracts the zero-based rank of an 0x88 square.\nfunction rank(square: number): number {\n  return square >> 4\n}\n\n// Extracts the zero-based file of an 0x88 square.\nfunction file(square: number): number {\n  return square & 0xf\n}\n\nfunction isDigit(c: string): boolean {\n  return '0123456789'.indexOf(c) !== -1\n}\n\n// Converts a 0x88 square to algebraic notation.\nfunction algebraic(square: number): Square {\n  const f = file(square)\n  const r = rank(square)\n  return ('abcdefgh'.substring(f, f + 1) +\n    '87654321'.substring(r, r + 1)) as Square\n}\n\nfunction swapColor(color: Color): Color {\n  return color === WHITE ? BLACK : WHITE\n}\n\nexport function validateFen(fen: string) {\n  // 1st criterion: 6 space-seperated fields?\n  const tokens = fen.split(/\\s+/)\n  if (tokens.length !== 6) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: must contain six space-delimited fields',\n    }\n  }\n\n  // 2nd criterion: move number field is a integer value > 0?\n  const moveNumber = parseInt(tokens[5], 10)\n  if (isNaN(moveNumber) || moveNumber <= 0) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: move number must be a positive integer',\n    }\n  }\n\n  // 3rd criterion: half move counter is an integer >= 0?\n  const halfMoves = parseInt(tokens[4], 10)\n  if (isNaN(halfMoves) || halfMoves < 0) {\n    return {\n      ok: false,\n      error:\n        'Invalid FEN: half move counter number must be a non-negative integer',\n    }\n  }\n\n  // 4th criterion: 4th field is a valid e.p.-string?\n  if (!/^(-|[abcdefgh][36])$/.test(tokens[3])) {\n    return { ok: false, error: 'Invalid FEN: en-passant square is invalid' }\n  }\n\n  // 5th criterion: 3th field is a valid castle-string?\n  if (/[^kKqQ-]/.test(tokens[2])) {\n    return { ok: false, error: 'Invalid FEN: castling availability is invalid' }\n  }\n\n  // 6th criterion: 2nd field is \"w\" (white) or \"b\" (black)?\n  if (!/^(w|b)$/.test(tokens[1])) {\n    return { ok: false, error: 'Invalid FEN: side-to-move is invalid' }\n  }\n\n  // 7th criterion: 1st field contains 8 rows?\n  const rows = tokens[0].split('/')\n  if (rows.length !== 8) {\n    return {\n      ok: false,\n      error: \"Invalid FEN: piece data does not contain 8 '/'-delimited rows\",\n    }\n  }\n\n  // 8th criterion: every row is valid?\n  for (let i = 0; i < rows.length; i++) {\n    // check for right sum of fields AND not two numbers in succession\n    let sumFields = 0\n    let previousWasNumber = false\n\n    for (let k = 0; k < rows[i].length; k++) {\n      if (isDigit(rows[i][k])) {\n        if (previousWasNumber) {\n          return {\n            ok: false,\n            error: 'Invalid FEN: piece data is invalid (consecutive number)',\n          }\n        }\n        sumFields += parseInt(rows[i][k], 10)\n        previousWasNumber = true\n      } else {\n        if (!/^[prnbqkPRNBQK]$/.test(rows[i][k])) {\n          return {\n            ok: false,\n            error: 'Invalid FEN: piece data is invalid (invalid piece)',\n          }\n        }\n        sumFields += 1\n        previousWasNumber = false\n      }\n    }\n    if (sumFields !== 8) {\n      return {\n        ok: false,\n        error: 'Invalid FEN: piece data is invalid (too many squares in rank)',\n      }\n    }\n  }\n\n  if (\n    (tokens[3][1] == '3' && tokens[1] == 'w') ||\n    (tokens[3][1] == '6' && tokens[1] == 'b')\n  ) {\n    return { ok: false, error: 'Invalid FEN: illegal en-passant square' }\n  }\n\n  const kings = [\n    { color: 'white', regex: /K/g },\n    { color: 'black', regex: /k/g },\n  ]\n\n  for (const { color, regex } of kings) {\n    if (!regex.test(tokens[0])) {\n      return { ok: false, error: `Invalid FEN: missing ${color} king` }\n    }\n\n    if ((tokens[0].match(regex) || []).length > 1) {\n      return { ok: false, error: `Invalid FEN: too many ${color} kings` }\n    }\n  }\n\n  return { ok: true }\n}\n\n// this function is used to uniquely identify ambiguous moves\nfunction getDisambiguator(move: InternalMove, moves: InternalMove[]) {\n  const from = move.from\n  const to = move.to\n  const piece = move.piece\n\n  let ambiguities = 0\n  let sameRank = 0\n  let sameFile = 0\n\n  for (let i = 0, len = moves.length; i < len; i++) {\n    const ambigFrom = moves[i].from\n    const ambigTo = moves[i].to\n    const ambigPiece = moves[i].piece\n\n    /*\n     * if a move of the same piece type ends on the same to square, we'll need\n     * to add a disambiguator to the algebraic notation\n     */\n    if (piece === ambigPiece && from !== ambigFrom && to === ambigTo) {\n      ambiguities++\n\n      if (rank(from) === rank(ambigFrom)) {\n        sameRank++\n      }\n\n      if (file(from) === file(ambigFrom)) {\n        sameFile++\n      }\n    }\n  }\n\n  if (ambiguities > 0) {\n    if (sameRank > 0 && sameFile > 0) {\n      /*\n       * if there exists a similar moving piece on the same rank and file as\n       * the move in question, use the square as the disambiguator\n       */\n      return algebraic(from)\n    } else if (sameFile > 0) {\n      /*\n       * if the moving piece rests on the same file, use the rank symbol as the\n       * disambiguator\n       */\n      return algebraic(from).charAt(1)\n    } else {\n      // else use the file symbol\n      return algebraic(from).charAt(0)\n    }\n  }\n\n  return ''\n}\n\nfunction addMove(\n  moves: InternalMove[],\n  color: Color,\n  from: number,\n  to: number,\n  piece: PieceSymbol,\n  captured: PieceSymbol | undefined = undefined,\n  flags: number = BITS.NORMAL\n) {\n  const r = rank(to)\n\n  if (piece === PAWN && (r === RANK_1 || r === RANK_8)) {\n    for (let i = 0; i < PROMOTIONS.length; i++) {\n      const promotion = PROMOTIONS[i]\n      moves.push({\n        color,\n        from,\n        to,\n        piece,\n        captured,\n        promotion,\n        flags: flags | BITS.PROMOTION,\n      })\n    }\n  } else {\n    moves.push({\n      color,\n      from,\n      to,\n      piece,\n      captured,\n      flags,\n    })\n  }\n}\n\nfunction inferPieceType(san: string) {\n  let pieceType = san.charAt(0)\n  if (pieceType >= 'a' && pieceType <= 'h') {\n    const matches = san.match(/[a-h]\\d.*[a-h]\\d/)\n    if (matches) {\n      return undefined\n    }\n    return PAWN\n  }\n  pieceType = pieceType.toLowerCase()\n  if (pieceType === 'o') {\n    return KING\n  }\n  return pieceType as PieceSymbol\n}\n\n// parses all of the decorators out of a SAN string\nfunction strippedSan(move: string) {\n  return move.replace(/=/, '').replace(/[+#]?[?!]*$/, '')\n}\n\nexport class Chess {\n  private _board = new Array<Piece>(128)\n  private _turn: Color = WHITE\n  private _header: Record<string, string> = {}\n  private _kings: Record<Color, number> = { w: EMPTY, b: EMPTY }\n  private _epSquare = -1\n  private _halfMoves = 0\n  private _moveNumber = 0\n  private _history: History[] = []\n  private _comments: Record<string, string> = {}\n  private _castling: Record<Color, number> = { w: 0, b: 0 }\n\n  constructor(fen = DEFAULT_POSITION) {\n    this.load(fen)\n  }\n\n  clear(keepHeaders = false) {\n    this._board = new Array<Piece>(128)\n    this._kings = { w: EMPTY, b: EMPTY }\n    this._turn = WHITE\n    this._castling = { w: 0, b: 0 }\n    this._epSquare = EMPTY\n    this._halfMoves = 0\n    this._moveNumber = 1\n    this._history = []\n    this._comments = {}\n    this._header = keepHeaders ? this._header : {}\n    this._updateSetup(this.fen())\n  }\n\n  removeHeader(key: string) {\n    if (key in this._header) {\n      delete this._header[key]\n    }\n  }\n\n  load(fen: string, keepHeaders = false) {\n    let tokens = fen.split(/\\s+/)\n\n    // append commonly omitted fen tokens\n    if (tokens.length >= 2 && tokens.length < 6) {\n      const adjustments = ['-', '-', '0', '1']\n      fen = tokens.concat(adjustments.slice(-(6 - tokens.length))).join(' ')\n    }\n\n    tokens = fen.split(/\\s+/)\n\n    const { ok, error } = validateFen(fen)\n    if (!ok) {\n      throw new Error(error)\n    }\n\n    const position = tokens[0]\n    let square = 0\n\n    this.clear(keepHeaders)\n\n    for (let i = 0; i < position.length; i++) {\n      const piece = position.charAt(i)\n\n      if (piece === '/') {\n        square += 8\n      } else if (isDigit(piece)) {\n        square += parseInt(piece, 10)\n      } else {\n        const color = piece < 'a' ? WHITE : BLACK\n        this.put(\n          { type: piece.toLowerCase() as PieceSymbol, color },\n          algebraic(square)\n        )\n        square++\n      }\n    }\n\n    this._turn = tokens[1] as Color\n\n    if (tokens[2].indexOf('K') > -1) {\n      this._castling.w |= BITS.KSIDE_CASTLE\n    }\n    if (tokens[2].indexOf('Q') > -1) {\n      this._castling.w |= BITS.QSIDE_CASTLE\n    }\n    if (tokens[2].indexOf('k') > -1) {\n      this._castling.b |= BITS.KSIDE_CASTLE\n    }\n    if (tokens[2].indexOf('q') > -1) {\n      this._castling.b |= BITS.QSIDE_CASTLE\n    }\n\n    this._epSquare = tokens[3] === '-' ? EMPTY : Ox88[tokens[3] as Square]\n    this._halfMoves = parseInt(tokens[4], 10)\n    this._moveNumber = parseInt(tokens[5], 10)\n\n    this._updateSetup(this.fen())\n  }\n\n  fen() {\n    let empty = 0\n    let fen = ''\n\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n      if (this._board[i]) {\n        if (empty > 0) {\n          fen += empty\n          empty = 0\n        }\n        const { color, type: piece } = this._board[i]\n\n        fen += color === WHITE ? piece.toUpperCase() : piece.toLowerCase()\n      } else {\n        empty++\n      }\n\n      if ((i + 1) & 0x88) {\n        if (empty > 0) {\n          fen += empty\n        }\n\n        if (i !== Ox88.h1) {\n          fen += '/'\n        }\n\n        empty = 0\n        i += 8\n      }\n    }\n\n    let castling = ''\n    if (this._castling[WHITE] & BITS.KSIDE_CASTLE) {\n      castling += 'K'\n    }\n    if (this._castling[WHITE] & BITS.QSIDE_CASTLE) {\n      castling += 'Q'\n    }\n    if (this._castling[BLACK] & BITS.KSIDE_CASTLE) {\n      castling += 'k'\n    }\n    if (this._castling[BLACK] & BITS.QSIDE_CASTLE) {\n      castling += 'q'\n    }\n\n    // do we have an empty castling flag?\n    castling = castling || '-'\n\n    let epSquare = '-'\n    /*\n     * only print the ep square if en passant is a valid move (pawn is present\n     * and ep capture is not pinned)\n     */\n    if (this._epSquare !== EMPTY) {\n      const bigPawnSquare = this._epSquare + (this._turn === WHITE ? 16 : -16)\n      const squares = [bigPawnSquare + 1, bigPawnSquare - 1]\n\n      for (const square of squares) {\n        // is the square off the board?\n        if (square & 0x88) {\n          continue\n        }\n\n        const color = this._turn\n\n        // is there a pawn that can capture the epSquare?\n        if (\n          this._board[square]?.color === color &&\n          this._board[square]?.type === PAWN\n        ) {\n          // if the pawn makes an ep capture, does it leave it's king in check?\n          this._makeMove({\n            color,\n            from: square,\n            to: this._epSquare,\n            piece: PAWN,\n            captured: PAWN,\n            flags: BITS.EP_CAPTURE,\n          })\n          const isLegal = !this._isKingAttacked(color)\n          this._undoMove()\n\n          // if ep is legal, break and set the ep square in the FEN output\n          if (isLegal) {\n            epSquare = algebraic(this._epSquare)\n            break\n          }\n        }\n      }\n    }\n\n    return [\n      fen,\n      this._turn,\n      castling,\n      epSquare,\n      this._halfMoves,\n      this._moveNumber,\n    ].join(' ')\n  }\n\n  /*\n   * Called when the initial board setup is changed with put() or remove().\n   * modifies the SetUp and FEN properties of the header object. If the FEN\n   * is equal to the default position, the SetUp and FEN are deleted the setup\n   * is only updated if history.length is zero, ie moves haven't been made.\n   */\n  private _updateSetup(fen: string) {\n    if (this._history.length > 0) return\n\n    if (fen !== DEFAULT_POSITION) {\n      this._header['SetUp'] = '1'\n      this._header['FEN'] = fen\n    } else {\n      delete this._header['SetUp']\n      delete this._header['FEN']\n    }\n  }\n\n  reset() {\n    this.load(DEFAULT_POSITION)\n  }\n\n  get(square: Square) {\n    return this._board[Ox88[square]] || false\n  }\n\n  put({ type, color }: { type: PieceSymbol; color: Color }, square: Square) {\n    // check for piece\n    if (SYMBOLS.indexOf(type.toLowerCase()) === -1) {\n      return false\n    }\n\n    // check for valid square\n    if (!(square in Ox88)) {\n      return false\n    }\n\n    const sq = Ox88[square]\n\n    // don't let the user place more than one king\n    if (\n      type == KING &&\n      !(this._kings[color] == EMPTY || this._kings[color] == sq)\n    ) {\n      return false\n    }\n\n    this._board[sq] = { type: type as PieceSymbol, color: color as Color }\n\n    if (type === KING) {\n      this._kings[color] = sq\n    }\n\n    this._updateCastlingRights()\n    this._updateEnPassantSquare()\n    this._updateSetup(this.fen())\n\n    return true\n  }\n\n  remove(square: Square) {\n    const piece = this.get(square)\n    delete this._board[Ox88[square]]\n    if (piece && piece.type === KING) {\n      this._kings[piece.color] = EMPTY\n    }\n\n    this._updateCastlingRights()\n    this._updateEnPassantSquare()\n    this._updateSetup(this.fen())\n\n    return piece\n  }\n\n  _updateCastlingRights() {\n    const whiteKingInPlace = (this._board[Ox88.e1]?.type === KING && this._board[Ox88.e1]?.color === WHITE)\n    const blackKingInPlace = (this._board[Ox88.e8]?.type === KING && this._board[Ox88.e8]?.color === BLACK)\n\n    if (!whiteKingInPlace || this._board[Ox88.a1]?.type !== ROOK || this._board[Ox88.a1]?.color !== WHITE) {\n      this._castling.w &= ~BITS.QSIDE_CASTLE\n    }\n\n    if (!whiteKingInPlace || this._board[Ox88.h1]?.type !== ROOK || this._board[Ox88.h1]?.color !== WHITE) {\n      this._castling.w &= ~BITS.KSIDE_CASTLE\n    }\n\n    if (!blackKingInPlace || this._board[Ox88.a8]?.type !== ROOK || this._board[Ox88.a8]?.color !== BLACK) {\n      this._castling.b &= ~BITS.QSIDE_CASTLE\n    }\n\n    if (!blackKingInPlace || this._board[Ox88.h8]?.type !== ROOK || this._board[Ox88.h8]?.color !== BLACK) {\n      this._castling.b &= ~BITS.KSIDE_CASTLE\n    }\n  }\n\n  _updateEnPassantSquare() {\n    if(this._epSquare === EMPTY) {\n      return\n    }\n\n    const startSquare = this._epSquare + (this._turn === WHITE ? -16 : 16)\n    const currentSquare = this._epSquare + (this._turn === WHITE ? 16 : -16)\n    const attackers = [currentSquare + 1, currentSquare - 1]\n\n    if (\n      this._board[startSquare] !== null ||\n      this._board[this._epSquare] !== null ||\n      this._board[currentSquare]?.color !== swapColor(this._turn) ||\n      this._board[currentSquare]?.type !== PAWN\n    ) {\n      this._epSquare = EMPTY\n      return\n    }\n\n    const canCapture = (square: number) =>\n      !(square & 0x88) &&\n      this._board[square]?.color === this._turn &&\n      this._board[square]?.type === PAWN;\n\n    if(!attackers.some(canCapture)) {\n      this._epSquare = EMPTY\n    }\n  }\n\n  _attacked(color: Color, square: number) {\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n      // did we run off the end of the board\n      if (i & 0x88) {\n        i += 7\n        continue\n      }\n\n      // if empty square or wrong color\n      if (this._board[i] === undefined || this._board[i].color !== color) {\n        continue\n      }\n\n      const piece = this._board[i]\n      const difference = i - square\n\n      // skip - to/from square are the same\n      if (difference === 0) {\n        continue\n      }\n\n      const index = difference + 119\n\n      if (ATTACKS[index] & PIECE_MASKS[piece.type]) {\n        if (piece.type === PAWN) {\n          if (difference > 0) {\n            if (piece.color === WHITE) return true\n          } else {\n            if (piece.color === BLACK) return true\n          }\n          continue\n        }\n\n        // if the piece is a knight or a king\n        if (piece.type === 'n' || piece.type === 'k') return true\n\n        const offset = RAYS[index]\n        let j = i + offset\n\n        let blocked = false\n        while (j !== square) {\n          if (this._board[j] != null) {\n            blocked = true\n            break\n          }\n          j += offset\n        }\n\n        if (!blocked) return true\n      }\n    }\n\n    return false\n  }\n\n  private _isKingAttacked(color: Color) {\n    const square = this._kings[color]\n    return square === -1 ? false : this._attacked(swapColor(color), square)\n  }\n\n  isAttacked(square: Square, attackedBy: Color) {\n    return this._attacked(attackedBy, Ox88[square])\n  }\n\n  isCheck() {\n    return this._isKingAttacked(this._turn)\n  }\n\n  inCheck() {\n    return this.isCheck()\n  }\n\n  isCheckmate() {\n    return this.isCheck() && this._moves().length === 0\n  }\n\n  isStalemate() {\n    return !this.isCheck() && this._moves().length === 0\n  }\n\n  isInsufficientMaterial() {\n    /*\n     * k.b. vs k.b. (of opposite colors) with mate in 1:\n     * 8/8/8/8/1b6/8/B1k5/K7 b - - 0 1\n     *\n     * k.b. vs k.n. with mate in 1:\n     * 8/8/8/8/1n6/8/B7/K1k5 b - - 2 1\n     */\n    const pieces: Record<PieceSymbol, number> = {\n      b: 0,\n      n: 0,\n      r: 0,\n      q: 0,\n      k: 0,\n      p: 0,\n    }\n    const bishops = []\n    let numPieces = 0\n    let squareColor = 0\n\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n      squareColor = (squareColor + 1) % 2\n      if (i & 0x88) {\n        i += 7\n        continue\n      }\n\n      const piece = this._board[i]\n      if (piece) {\n        pieces[piece.type] = piece.type in pieces ? pieces[piece.type] + 1 : 1\n        if (piece.type === BISHOP) {\n          bishops.push(squareColor)\n        }\n        numPieces++\n      }\n    }\n\n    // k vs. k\n    if (numPieces === 2) {\n      return true\n    } else if (\n      // k vs. kn .... or .... k vs. kb\n      numPieces === 3 &&\n      (pieces[BISHOP] === 1 || pieces[KNIGHT] === 1)\n    ) {\n      return true\n    } else if (numPieces === pieces[BISHOP] + 2) {\n      // kb vs. kb where any number of bishops are all on the same color\n      let sum = 0\n      const len = bishops.length\n      for (let i = 0; i < len; i++) {\n        sum += bishops[i]\n      }\n      if (sum === 0 || sum === len) {\n        return true\n      }\n    }\n\n    return false\n  }\n\n  isThreefoldRepetition() {\n    const moves = []\n    const positions: Record<string, number> = {}\n    let repetition = false\n\n    while (true) {\n      const move = this._undoMove()\n      if (!move) break\n      moves.push(move)\n    }\n\n    while (true) {\n      /*\n       * remove the last two fields in the FEN string, they're not needed when\n       * checking for draw by rep\n       */\n      const fen = this.fen().split(' ').slice(0, 4).join(' ')\n\n      // has the position occurred three or move times\n      positions[fen] = fen in positions ? positions[fen] + 1 : 1\n      if (positions[fen] >= 3) {\n        repetition = true\n      }\n\n      const move = moves.pop()\n\n      if (!move) {\n        break\n      } else {\n        this._makeMove(move)\n      }\n    }\n\n    return repetition\n  }\n\n  isDraw() {\n    return (\n      this._halfMoves >= 100 || // 50 moves per side = 100 half moves\n      this.isStalemate() ||\n      this.isInsufficientMaterial() ||\n      this.isThreefoldRepetition()\n    )\n  }\n\n  isGameOver() {\n    return this.isCheckmate() || this.isStalemate() || this.isDraw()\n  }\n\n  moves(): string[]\n  moves({ square }: { square: Square }): string[]\n  moves({ piece }: { piece: PieceSymbol }): string[]\n\n  moves({ square, piece }: { square: Square; piece: PieceSymbol }): string[]\n\n  moves({ verbose, square }: { verbose: true; square?: Square }): Move[]\n  moves({ verbose, square }: { verbose: false; square?: Square }): string[]\n  moves({\n    verbose,\n    square,\n  }: {\n    verbose?: boolean\n    square?: Square\n  }): string[] | Move[]\n\n  moves({ verbose, piece }: { verbose: true; piece?: PieceSymbol }): Move[]\n  moves({ verbose, piece }: { verbose: false; piece?: PieceSymbol }): string[]\n  moves({\n    verbose,\n    piece,\n  }: {\n    verbose?: boolean\n    piece?: PieceSymbol\n  }): string[] | Move[]\n\n  moves({\n    verbose,\n    square,\n    piece,\n  }: {\n    verbose: true\n    square?: Square\n    piece?: PieceSymbol\n  }): Move[]\n  moves({\n    verbose,\n    square,\n    piece,\n  }: {\n    verbose: false\n    square?: Square\n    piece?: PieceSymbol\n  }): string[]\n  moves({\n    verbose,\n    square,\n    piece,\n  }: {\n    verbose?: boolean\n    square?: Square\n    piece?: PieceSymbol\n  }): string[] | Move[]\n\n  moves({ square, piece }: { square?: Square; piece?: PieceSymbol }): Move[]\n\n  moves({\n    verbose = false,\n    square = undefined,\n    piece = undefined,\n  }: { verbose?: boolean; square?: Square; piece?: PieceSymbol } = {}) {\n    const moves = this._moves({ square, piece })\n\n    if (verbose) {\n      return moves.map((move) => this._makePretty(move))\n    } else {\n      return moves.map((move) => this._moveToSan(move, moves))\n    }\n  }\n\n  _moves({\n    legal = true,\n    piece = undefined,\n    square = undefined,\n  }: {\n    legal?: boolean\n    piece?: PieceSymbol\n    square?: Square\n  } = {}) {\n    const forSquare = square ? (square.toLowerCase() as Square) : undefined\n    const forPiece = piece?.toLowerCase()\n\n    const moves: InternalMove[] = []\n    const us = this._turn\n    const them = swapColor(us)\n\n    let firstSquare = Ox88.a8\n    let lastSquare = Ox88.h1\n    let singleSquare = false\n\n    // are we generating moves for a single square?\n    if (forSquare) {\n      // illegal square, return empty moves\n      if (!(forSquare in Ox88)) {\n        return []\n      } else {\n        firstSquare = lastSquare = Ox88[forSquare]\n        singleSquare = true\n      }\n    }\n\n    for (let from = firstSquare; from <= lastSquare; from++) {\n      // did we run off the end of the board\n      if (from & 0x88) {\n        from += 7\n        continue\n      }\n\n      // empty square or opponent, skip\n      if (!this._board[from] || this._board[from].color === them) {\n        continue\n      }\n      const { type } = this._board[from]\n\n      let to: number\n      if (type === PAWN) {\n        if (forPiece && forPiece !== type) continue\n\n        // single square, non-capturing\n        to = from + PAWN_OFFSETS[us][0]\n        if (!this._board[to]) {\n          addMove(moves, us, from, to, PAWN)\n\n          // double square\n          to = from + PAWN_OFFSETS[us][1]\n          if (SECOND_RANK[us] === rank(from) && !this._board[to]) {\n            addMove(moves, us, from, to, PAWN, undefined, BITS.BIG_PAWN)\n          }\n        }\n\n        // pawn captures\n        for (let j = 2; j < 4; j++) {\n          to = from + PAWN_OFFSETS[us][j]\n          if (to & 0x88) continue\n\n          if (this._board[to]?.color === them) {\n            addMove(\n              moves,\n              us,\n              from,\n              to,\n              PAWN,\n              this._board[to].type,\n              BITS.CAPTURE\n            )\n          } else if (to === this._epSquare) {\n            addMove(moves, us, from, to, PAWN, PAWN, BITS.EP_CAPTURE)\n          }\n        }\n      } else {\n        if (forPiece && forPiece !== type) continue\n\n        for (let j = 0, len = PIECE_OFFSETS[type].length; j < len; j++) {\n          const offset = PIECE_OFFSETS[type][j]\n          to = from\n\n          while (true) {\n            to += offset\n            if (to & 0x88) break\n\n            if (!this._board[to]) {\n              addMove(moves, us, from, to, type)\n            } else {\n              // own color, stop loop\n              if (this._board[to].color === us) break\n\n              addMove(\n                moves,\n                us,\n                from,\n                to,\n                type,\n                this._board[to].type,\n                BITS.CAPTURE\n              )\n              break\n            }\n\n            /* break, if knight or king */\n            if (type === KNIGHT || type === KING) break\n          }\n        }\n      }\n    }\n\n    /*\n     * check for castling if we're:\n     *   a) generating all moves, or\n     *   b) doing single square move generation on the king's square\n     */\n\n    if (forPiece === undefined || forPiece === KING) {\n      if (!singleSquare || lastSquare === this._kings[us]) {\n        // king-side castling\n        if (this._castling[us] & BITS.KSIDE_CASTLE) {\n          const castlingFrom = this._kings[us]\n          const castlingTo = castlingFrom + 2\n\n          if (\n            !this._board[castlingFrom + 1] &&\n            !this._board[castlingTo] &&\n            !this._attacked(them, this._kings[us]) &&\n            !this._attacked(them, castlingFrom + 1) &&\n            !this._attacked(them, castlingTo)\n          ) {\n            addMove(\n              moves,\n              us,\n              this._kings[us],\n              castlingTo,\n              KING,\n              undefined,\n              BITS.KSIDE_CASTLE\n            )\n          }\n        }\n\n        // queen-side castling\n        if (this._castling[us] & BITS.QSIDE_CASTLE) {\n          const castlingFrom = this._kings[us]\n          const castlingTo = castlingFrom - 2\n\n          if (\n            !this._board[castlingFrom - 1] &&\n            !this._board[castlingFrom - 2] &&\n            !this._board[castlingFrom - 3] &&\n            !this._attacked(them, this._kings[us]) &&\n            !this._attacked(them, castlingFrom - 1) &&\n            !this._attacked(them, castlingTo)\n          ) {\n            addMove(\n              moves,\n              us,\n              this._kings[us],\n              castlingTo,\n              KING,\n              undefined,\n              BITS.QSIDE_CASTLE\n            )\n          }\n        }\n      }\n    }\n\n    /*\n     * return all pseudo-legal moves (this includes moves that allow the king\n     * to be captured)\n     */\n    if (!legal || this._kings[us] === -1) {\n      return moves\n    }\n\n    // filter out illegal moves\n    const legalMoves = []\n\n    for (let i = 0, len = moves.length; i < len; i++) {\n      this._makeMove(moves[i])\n      if (!this._isKingAttacked(us)) {\n        legalMoves.push(moves[i])\n      }\n      this._undoMove()\n    }\n\n    return legalMoves\n  }\n\n  move(\n    move: string | { from: string; to: string; promotion?: string },\n    { strict = false }: { strict?: boolean } = {}\n  ) {\n    /*\n     * The move function can be called with in the following parameters:\n     *\n     * .move('Nxb7')       <- argument is a case-sensitive SAN string\n     *\n     * .move({ from: 'h7', <- argument is a move object\n     *         to :'h8',\n     *         promotion: 'q' })\n     *\n     *\n     * An optional strict argument may be supplied to tell chess.js to\n     * strictly follow the SAN specification.\n     */\n\n    let moveObj = null\n\n    if (typeof move === 'string') {\n      moveObj = this._moveFromSan(move, strict)\n    } else if (typeof move === 'object') {\n      const moves = this._moves()\n\n      // convert the pretty move object to an ugly move object\n      for (let i = 0, len = moves.length; i < len; i++) {\n        if (\n          move.from === algebraic(moves[i].from) &&\n          move.to === algebraic(moves[i].to) &&\n          (!('promotion' in moves[i]) || move.promotion === moves[i].promotion)\n        ) {\n          moveObj = moves[i]\n          break\n        }\n      }\n    }\n\n    // failed to find move\n    if (!moveObj) {\n      if (typeof move === 'string') {\n        throw new Error(`Invalid move: ${move}`)\n      } else {\n        throw new Error(`Invalid move: ${JSON.stringify(move)}`)\n      }\n    }\n\n    /*\n     * need to make a copy of move because we can't generate SAN after the move\n     * is made\n     */\n    const prettyMove = this._makePretty(moveObj)\n\n    this._makeMove(moveObj)\n\n    return prettyMove\n  }\n\n  _push(move: InternalMove) {\n    this._history.push({\n      move,\n      kings: { b: this._kings.b, w: this._kings.w },\n      turn: this._turn,\n      castling: { b: this._castling.b, w: this._castling.w },\n      epSquare: this._epSquare,\n      halfMoves: this._halfMoves,\n      moveNumber: this._moveNumber,\n    })\n  }\n\n  private _makeMove(move: InternalMove) {\n    const us = this._turn\n    const them = swapColor(us)\n    this._push(move)\n\n    this._board[move.to] = this._board[move.from]\n    delete this._board[move.from]\n\n    // if ep capture, remove the captured pawn\n    if (move.flags & BITS.EP_CAPTURE) {\n      if (this._turn === BLACK) {\n        delete this._board[move.to - 16]\n      } else {\n        delete this._board[move.to + 16]\n      }\n    }\n\n    // if pawn promotion, replace with new piece\n    if (move.promotion) {\n      this._board[move.to] = { type: move.promotion, color: us }\n    }\n\n    // if we moved the king\n    if (this._board[move.to].type === KING) {\n      this._kings[us] = move.to\n\n      // if we castled, move the rook next to the king\n      if (move.flags & BITS.KSIDE_CASTLE) {\n        const castlingTo = move.to - 1\n        const castlingFrom = move.to + 1\n        this._board[castlingTo] = this._board[castlingFrom]\n        delete this._board[castlingFrom]\n      } else if (move.flags & BITS.QSIDE_CASTLE) {\n        const castlingTo = move.to + 1\n        const castlingFrom = move.to - 2\n        this._board[castlingTo] = this._board[castlingFrom]\n        delete this._board[castlingFrom]\n      }\n\n      // turn off castling\n      this._castling[us] = 0\n    }\n\n    // turn off castling if we move a rook\n    if (this._castling[us]) {\n      for (let i = 0, len = ROOKS[us].length; i < len; i++) {\n        if (\n          move.from === ROOKS[us][i].square &&\n          this._castling[us] & ROOKS[us][i].flag\n        ) {\n          this._castling[us] ^= ROOKS[us][i].flag\n          break\n        }\n      }\n    }\n\n    // turn off castling if we capture a rook\n    if (this._castling[them]) {\n      for (let i = 0, len = ROOKS[them].length; i < len; i++) {\n        if (\n          move.to === ROOKS[them][i].square &&\n          this._castling[them] & ROOKS[them][i].flag\n        ) {\n          this._castling[them] ^= ROOKS[them][i].flag\n          break\n        }\n      }\n    }\n\n    // if big pawn move, update the en passant square\n    if (move.flags & BITS.BIG_PAWN) {\n      if (us === BLACK) {\n        this._epSquare = move.to - 16\n      } else {\n        this._epSquare = move.to + 16\n      }\n    } else {\n      this._epSquare = EMPTY\n    }\n\n    // reset the 50 move counter if a pawn is moved or a piece is captured\n    if (move.piece === PAWN) {\n      this._halfMoves = 0\n    } else if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n      this._halfMoves = 0\n    } else {\n      this._halfMoves++\n    }\n\n    if (us === BLACK) {\n      this._moveNumber++\n    }\n\n    this._turn = them\n  }\n\n  undo() {\n    const move = this._undoMove()\n    return move ? this._makePretty(move) : null\n  }\n\n  private _undoMove() {\n    const old = this._history.pop()\n    if (old === undefined) {\n      return null\n    }\n\n    const move = old.move\n\n    this._kings = old.kings\n    this._turn = old.turn\n    this._castling = old.castling\n    this._epSquare = old.epSquare\n    this._halfMoves = old.halfMoves\n    this._moveNumber = old.moveNumber\n\n    const us = this._turn\n    const them = swapColor(us)\n\n    this._board[move.from] = this._board[move.to]\n    this._board[move.from].type = move.piece // to undo any promotions\n    delete this._board[move.to]\n\n    if (move.captured) {\n      if (move.flags & BITS.EP_CAPTURE) {\n        // en passant capture\n        let index: number\n        if (us === BLACK) {\n          index = move.to - 16\n        } else {\n          index = move.to + 16\n        }\n        this._board[index] = { type: PAWN, color: them }\n      } else {\n        // regular capture\n        this._board[move.to] = { type: move.captured, color: them }\n      }\n    }\n\n    if (move.flags & (BITS.KSIDE_CASTLE | BITS.QSIDE_CASTLE)) {\n      let castlingTo: number, castlingFrom: number\n      if (move.flags & BITS.KSIDE_CASTLE) {\n        castlingTo = move.to + 1\n        castlingFrom = move.to - 1\n      } else {\n        castlingTo = move.to - 2\n        castlingFrom = move.to + 1\n      }\n\n      this._board[castlingTo] = this._board[castlingFrom]\n      delete this._board[castlingFrom]\n    }\n\n    return move\n  }\n\n  pgn({\n    newline = '\\n',\n    maxWidth = 0,\n  }: { newline?: string; maxWidth?: number } = {}) {\n    /*\n     * using the specification from http://www.chessclub.com/help/PGN-spec\n     * example for html usage: .pgn({ max_width: 72, newline_char: \"<br />\" })\n     */\n\n    const result: string[] = []\n    let headerExists = false\n\n    /* add the PGN header information */\n    for (const i in this._header) {\n      /*\n       * TODO: order of enumerated properties in header object is not\n       * guaranteed, see ECMA-262 spec (section 12.6.4)\n       */\n      result.push('[' + i + ' \"' + this._header[i] + '\"]' + newline)\n      headerExists = true\n    }\n\n    if (headerExists && this._history.length) {\n      result.push(newline)\n    }\n\n    const appendComment = (moveString: string) => {\n      const comment = this._comments[this.fen()]\n      if (typeof comment !== 'undefined') {\n        const delimiter = moveString.length > 0 ? ' ' : ''\n        moveString = `${moveString}${delimiter}{${comment}}`\n      }\n      return moveString\n    }\n\n    // pop all of history onto reversed_history\n    const reversedHistory = []\n    while (this._history.length > 0) {\n      reversedHistory.push(this._undoMove())\n    }\n\n    const moves = []\n    let moveString = ''\n\n    // special case of a commented starting position with no moves\n    if (reversedHistory.length === 0) {\n      moves.push(appendComment(''))\n    }\n\n    // build the list of moves.  a move_string looks like: \"3. e3 e6\"\n    while (reversedHistory.length > 0) {\n      moveString = appendComment(moveString)\n      const move = reversedHistory.pop()\n\n      // make TypeScript stop complaining about move being undefined\n      if (!move) {\n        break\n      }\n\n      // if the position started with black to move, start PGN with #. ...\n      if (!this._history.length && move.color === 'b') {\n        const prefix = `${this._moveNumber}. ...`\n        // is there a comment preceding the first move?\n        moveString = moveString ? `${moveString} ${prefix}` : prefix\n      } else if (move.color === 'w') {\n        // store the previous generated move_string if we have one\n        if (moveString.length) {\n          moves.push(moveString)\n        }\n        moveString = this._moveNumber + '.'\n      }\n\n      moveString =\n        moveString + ' ' + this._moveToSan(move, this._moves({ legal: true }))\n      this._makeMove(move)\n    }\n\n    // are there any other leftover moves?\n    if (moveString.length) {\n      moves.push(appendComment(moveString))\n    }\n\n    // is there a result?\n    if (typeof this._header.Result !== 'undefined') {\n      moves.push(this._header.Result)\n    }\n\n    /*\n     * history should be back to what it was before we started generating PGN,\n     * so join together moves\n     */\n    if (maxWidth === 0) {\n      return result.join('') + moves.join(' ')\n    }\n\n    // TODO (jah): huh?\n    const strip = function () {\n      if (result.length > 0 && result[result.length - 1] === ' ') {\n        result.pop()\n        return true\n      }\n      return false\n    }\n\n    // NB: this does not preserve comment whitespace.\n    const wrapComment = function (width: number, move: string) {\n      for (const token of move.split(' ')) {\n        if (!token) {\n          continue\n        }\n        if (width + token.length > maxWidth) {\n          while (strip()) {\n            width--\n          }\n          result.push(newline)\n          width = 0\n        }\n        result.push(token)\n        width += token.length\n        result.push(' ')\n        width++\n      }\n      if (strip()) {\n        width--\n      }\n      return width\n    }\n\n    // wrap the PGN output at max_width\n    let currentWidth = 0\n    for (let i = 0; i < moves.length; i++) {\n      if (currentWidth + moves[i].length > maxWidth) {\n        if (moves[i].includes('{')) {\n          currentWidth = wrapComment(currentWidth, moves[i])\n          continue\n        }\n      }\n      // if the current move will push past max_width\n      if (currentWidth + moves[i].length > maxWidth && i !== 0) {\n        // don't end the line with whitespace\n        if (result[result.length - 1] === ' ') {\n          result.pop()\n        }\n\n        result.push(newline)\n        currentWidth = 0\n      } else if (i !== 0) {\n        result.push(' ')\n        currentWidth++\n      }\n      result.push(moves[i])\n      currentWidth += moves[i].length\n    }\n\n    return result.join('')\n  }\n\n  header(...args: string[]) {\n    for (let i = 0; i < args.length; i += 2) {\n      if (typeof args[i] === 'string' && typeof args[i + 1] === 'string') {\n        this._header[args[i]] = args[i + 1]\n      }\n    }\n    return this._header\n  }\n\n  loadPgn(\n    pgn: string,\n    {\n      strict = false,\n      newlineChar = '\\r?\\n',\n    }: { strict?: boolean; newlineChar?: string } = {}\n  ) {\n    function mask(str: string): string {\n      return str.replace(/\\\\/g, '\\\\')\n    }\n\n    function parsePgnHeader(header: string): { [key: string]: string } {\n      const headerObj: Record<string, string> = {}\n      const headers = header.split(new RegExp(mask(newlineChar)))\n      let key = ''\n      let value = ''\n\n      for (let i = 0; i < headers.length; i++) {\n        const regex = /^\\s*\\[\\s*([A-Za-z]+)\\s*\"(.*)\"\\s*\\]\\s*$/\n        key = headers[i].replace(regex, '$1')\n        value = headers[i].replace(regex, '$2')\n        if (key.trim().length > 0) {\n          headerObj[key] = value\n        }\n      }\n\n      return headerObj\n    }\n\n    // strip whitespace from head/tail of PGN block\n    pgn = pgn.trim()\n\n    /*\n     * RegExp to split header. Takes advantage of the fact that header and movetext\n     * will always have a blank line between them (ie, two newline_char's). Handles\n     * case where movetext is empty by matching newlineChar until end of string is\n     * matched - effectively trimming from the end extra newlineChar.\n     *\n     * With default newline_char, will equal:\n     * /^(\\[((?:\\r?\\n)|.)*\\])((?:\\s*\\r?\\n){2}|(?:\\s*\\r?\\n)*$)/\n     */\n    const headerRegex = new RegExp(\n      '^(\\\\[((?:' +\n        mask(newlineChar) +\n        ')|.)*\\\\])' +\n        '((?:\\\\s*' +\n        mask(newlineChar) +\n        '){2}|(?:\\\\s*' +\n        mask(newlineChar) +\n        ')*$)'\n    )\n\n    // If no header given, begin with moves.\n    const headerRegexResults = headerRegex.exec(pgn)\n    const headerString = headerRegexResults\n      ? headerRegexResults.length >= 2\n        ? headerRegexResults[1]\n        : ''\n      : ''\n\n    // Put the board in the starting position\n    this.reset()\n\n    // parse PGN header\n    const headers = parsePgnHeader(headerString)\n    let fen = ''\n\n    for (const key in headers) {\n      // check to see user is including fen (possibly with wrong tag case)\n      if (key.toLowerCase() === 'fen') {\n        fen = headers[key]\n      }\n\n      this.header(key, headers[key])\n    }\n\n    /*\n     * the permissive parser should attempt to load a fen tag, even if it's the\n     * wrong case and doesn't include a corresponding [SetUp \"1\"] tag\n     */\n    if (!strict) {\n      if (fen) {\n        this.load(fen, true)\n      }\n    } else {\n      /*\n       * strict parser - load the starting position indicated by [Setup '1']\n       * and [FEN position]\n       */\n      if (headers['SetUp'] === '1') {\n        if (!('FEN' in headers)) {\n          throw new Error(\n            'Invalid PGN: FEN tag must be supplied with SetUp tag'\n          )\n        }\n        // second argument to load: don't clear the headers\n        this.load(headers['FEN'], true)\n      }\n    }\n\n    /*\n     * NB: the regexes below that delete move numbers, recursive annotations,\n     * and numeric annotation glyphs may also match text in comments. To\n     * prevent this, we transform comments by hex-encoding them in place and\n     * decoding them again after the other tokens have been deleted.\n     *\n     * While the spec states that PGN files should be ASCII encoded, we use\n     * {en,de}codeURIComponent here to support arbitrary UTF8 as a convenience\n     * for modern users\n     */\n\n    function toHex(s: string): string {\n      return Array.from(s)\n        .map(function (c) {\n          /*\n           * encodeURI doesn't transform most ASCII characters, so we handle\n           * these ourselves\n           */\n          return c.charCodeAt(0) < 128\n            ? c.charCodeAt(0).toString(16)\n            : encodeURIComponent(c).replace(/%/g, '').toLowerCase()\n        })\n        .join('')\n    }\n\n    function fromHex(s: string): string {\n      return s.length == 0\n        ? ''\n        : decodeURIComponent('%' + (s.match(/.{1,2}/g) || []).join('%'))\n    }\n\n    const encodeComment = function (s: string) {\n      s = s.replace(new RegExp(mask(newlineChar), 'g'), ' ')\n      return `{${toHex(s.slice(1, s.length - 1))}}`\n    }\n\n    const decodeComment = function (s: string) {\n      if (s.startsWith('{') && s.endsWith('}')) {\n        return fromHex(s.slice(1, s.length - 1))\n      }\n    }\n\n    // delete header to get the moves\n    let ms = pgn\n      .replace(headerString, '')\n      .replace(\n        // encode comments so they don't get deleted below\n        new RegExp(`({[^}]*})+?|;([^${mask(newlineChar)}]*)`, 'g'),\n        function (_match, bracket, semicolon) {\n          return bracket !== undefined\n            ? encodeComment(bracket)\n            : ' ' + encodeComment(`{${semicolon.slice(1)}}`)\n        }\n      )\n      .replace(new RegExp(mask(newlineChar), 'g'), ' ')\n\n    // delete recursive annotation variations\n    const ravRegex = /(\\([^()]+\\))+?/g\n    while (ravRegex.test(ms)) {\n      ms = ms.replace(ravRegex, '')\n    }\n\n    // delete move numbers\n    ms = ms.replace(/\\d+\\.(\\.\\.)?/g, '')\n\n    // delete ... indicating black to move\n    ms = ms.replace(/\\.\\.\\./g, '')\n\n    /* delete numeric annotation glyphs */\n    ms = ms.replace(/\\$\\d+/g, '')\n\n    // trim and get array of moves\n    let moves = ms.trim().split(new RegExp(/\\s+/))\n\n    // delete empty entries\n    moves = moves.filter((move) => move !== '')\n\n    let result = ''\n\n    for (let halfMove = 0; halfMove < moves.length; halfMove++) {\n      const comment = decodeComment(moves[halfMove])\n      if (comment !== undefined) {\n        this._comments[this.fen()] = comment\n        continue\n      }\n\n      const move = this._moveFromSan(moves[halfMove], strict)\n\n      // invalid move\n      if (move == null) {\n        // was the move an end of game marker\n        if (TERMINATION_MARKERS.indexOf(moves[halfMove]) > -1) {\n          result = moves[halfMove]\n        } else {\n          throw new Error(`Invalid move in PGN: ${moves[halfMove]}`)\n        }\n      } else {\n        // reset the end of game marker if making a valid move\n        result = ''\n        this._makeMove(move)\n      }\n    }\n\n    /*\n     * Per section 8.2.6 of the PGN spec, the Result tag pair must match match\n     * the termination marker. Only do this when headers are present, but the\n     * result tag is missing\n     */\n\n    if (result && Object.keys(this._header).length && !this._header['Result']) {\n      this.header('Result', result)\n    }\n  }\n\n  /*\n   * Convert a move from 0x88 coordinates to Standard Algebraic Notation\n   * (SAN)\n   *\n   * @param {boolean} strict Use the strict SAN parser. It will throw errors\n   * on overly disambiguated moves (see below):\n   *\n   * r1bqkbnr/ppp2ppp/2n5/1B1pP3/4P3/8/PPPP2PP/RNBQK1NR b KQkq - 2 4\n   * 4. ... Nge7 is overly disambiguated because the knight on c6 is pinned\n   * 4. ... Ne7 is technically the valid SAN\n   */\n\n  private _moveToSan(move: InternalMove, moves: InternalMove[]) {\n    let output = ''\n\n    if (move.flags & BITS.KSIDE_CASTLE) {\n      output = 'O-O'\n    } else if (move.flags & BITS.QSIDE_CASTLE) {\n      output = 'O-O-O'\n    } else {\n      if (move.piece !== PAWN) {\n        const disambiguator = getDisambiguator(move, moves)\n        output += move.piece.toUpperCase() + disambiguator\n      }\n\n      if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n        if (move.piece === PAWN) {\n          output += algebraic(move.from)[0]\n        }\n        output += 'x'\n      }\n\n      output += algebraic(move.to)\n\n      if (move.promotion) {\n        output += '=' + move.promotion.toUpperCase()\n      }\n    }\n\n    this._makeMove(move)\n    if (this.isCheck()) {\n      if (this.isCheckmate()) {\n        output += '#'\n      } else {\n        output += '+'\n      }\n    }\n    this._undoMove()\n\n    return output\n  }\n\n  // convert a move from Standard Algebraic Notation (SAN) to 0x88 coordinates\n  private _moveFromSan(move: string, strict = false): InternalMove | null {\n    // strip off any move decorations: e.g Nf3+?! becomes Nf3\n    const cleanMove = strippedSan(move)\n\n    let pieceType = inferPieceType(cleanMove)\n    let moves = this._moves({ legal: true, piece: pieceType })\n\n    // strict parser\n    for (let i = 0, len = moves.length; i < len; i++) {\n      if (cleanMove === strippedSan(this._moveToSan(moves[i], moves))) {\n        return moves[i]\n      }\n    }\n\n    // the strict parser failed\n    if (strict) {\n      return null\n    }\n\n    let piece = undefined\n    let matches = undefined\n    let from = undefined\n    let to = undefined\n    let promotion = undefined\n\n    /*\n     * The default permissive (non-strict) parser allows the user to parse\n     * non-standard chess notations. This parser is only run after the strict\n     * Standard Algebraic Notation (SAN) parser has failed.\n     *\n     * When running the permissive parser, we'll run a regex to grab the piece, the\n     * to/from square, and an optional promotion piece. This regex will\n     * parse common non-standard notation like: Pe2-e4, Rc1c4, Qf3xf7,\n     * f7f8q, b1c3\n     *\n     * NOTE: Some positions and moves may be ambiguous when using the permissive\n     * parser. For example, in this position: 6k1/8/8/B7/8/8/8/BN4K1 w - - 0 1,\n     * the move b1c3 may be interpreted as Nc3 or B1c3 (a disambiguated bishop\n     * move). In these cases, the permissive parser will default to the most\n     * basic interpretation (which is b1c3 parsing to Nc3).\n     */\n\n    let overlyDisambiguated = false\n\n    matches = cleanMove.match(\n      /([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/\n      //     piece         from              to       promotion\n    )\n\n    if (matches) {\n      piece = matches[1]\n      from = matches[2] as Square\n      to = matches[3] as Square\n      promotion = matches[4]\n\n      if (from.length == 1) {\n        overlyDisambiguated = true\n      }\n    } else {\n      /*\n       * The [a-h]?[1-8]? portion of the regex below handles moves that may be\n       * overly disambiguated (e.g. Nge7 is unnecessary and non-standard when\n       * there is one legal knight move to e7). In this case, the value of\n       * 'from' variable will be a rank or file, not a square.\n       */\n\n      matches = cleanMove.match(\n        /([pnbrqkPNBRQK])?([a-h]?[1-8]?)x?-?([a-h][1-8])([qrbnQRBN])?/\n      )\n\n      if (matches) {\n        piece = matches[1]\n        from = matches[2] as Square\n        to = matches[3] as Square\n        promotion = matches[4]\n\n        if (from.length == 1) {\n          overlyDisambiguated = true\n        }\n      }\n    }\n\n    pieceType = inferPieceType(cleanMove)\n    moves = this._moves({\n      legal: true,\n      piece: piece ? (piece as PieceSymbol) : pieceType,\n    })\n\n    if (!to) {\n      return null;\n    }\n\n    for (let i = 0, len = moves.length; i < len; i++) {\n      if (!from) {\n          // if there is no from square, it could be just 'x' missing from a capture\n          if (cleanMove === strippedSan(this._moveToSan(moves[i], moves)).replace('x', '')) {\n            return moves[i];\n          }\n      // hand-compare move properties with the results from our permissive regex\n      } else if (\n          (!piece || piece.toLowerCase() == moves[i].piece) &&\n          Ox88[from] == moves[i].from &&\n          Ox88[to] == moves[i].to &&\n          (!promotion || promotion.toLowerCase() == moves[i].promotion)\n      ) {\n        return moves[i]\n      } else if (overlyDisambiguated) {\n        /*\n         * SPECIAL CASE: we parsed a move string that may have an unneeded\n         * rank/file disambiguator (e.g. Nge7).  The 'from' variable will\n         */\n\n        const square = algebraic(moves[i].from)\n        if (\n          (!piece || piece.toLowerCase() == moves[i].piece) &&\n          Ox88[to] == moves[i].to &&\n          (from == square[0] || from == square[1]) &&\n          (!promotion || promotion.toLowerCase() == moves[i].promotion)\n        ) {\n          return moves[i]\n        }\n      }\n    }\n\n    return null\n  }\n\n  ascii() {\n    let s = '   +------------------------+\\n'\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n      // display the rank\n      if (file(i) === 0) {\n        s += ' ' + '87654321'[rank(i)] + ' |'\n      }\n\n      if (this._board[i]) {\n        const piece = this._board[i].type\n        const color = this._board[i].color\n        const symbol =\n          color === WHITE ? piece.toUpperCase() : piece.toLowerCase()\n        s += ' ' + symbol + ' '\n      } else {\n        s += ' . '\n      }\n\n      if ((i + 1) & 0x88) {\n        s += '|\\n'\n        i += 8\n      }\n    }\n    s += '   +------------------------+\\n'\n    s += '     a  b  c  d  e  f  g  h'\n\n    return s\n  }\n\n  perft(depth: number) {\n    const moves = this._moves({ legal: false })\n    let nodes = 0\n    const color = this._turn\n\n    for (let i = 0, len = moves.length; i < len; i++) {\n      this._makeMove(moves[i])\n      if (!this._isKingAttacked(color)) {\n        if (depth - 1 > 0) {\n          nodes += this.perft(depth - 1)\n        } else {\n          nodes++\n        }\n      }\n      this._undoMove()\n    }\n\n    return nodes\n  }\n\n  // pretty = external move object\n  private _makePretty(uglyMove: InternalMove): Move {\n    const { color, piece, from, to, flags, captured, promotion } = uglyMove\n\n    let prettyFlags = ''\n\n    for (const flag in BITS) {\n      if (BITS[flag] & flags) {\n        prettyFlags += FLAGS[flag]\n      }\n    }\n\n    const fromAlgebraic = algebraic(from)\n    const toAlgebraic = algebraic(to)\n\n    const move: Move = {\n      color,\n      piece,\n      from: fromAlgebraic,\n      to: toAlgebraic,\n      san: this._moveToSan(uglyMove, this._moves({ legal: true })),\n      flags: prettyFlags,\n      lan: fromAlgebraic + toAlgebraic,\n      before: this.fen(),\n      after: '',\n    }\n\n    // generate the FEN for the 'after' key\n    this._makeMove(uglyMove)\n    move.after = this.fen()\n    this._undoMove()\n\n    if (captured) {\n      move.captured = captured\n    }\n    if (promotion) {\n      move.promotion = promotion\n      move.lan += promotion\n    }\n\n    return move\n  }\n\n  turn() {\n    return this._turn\n  }\n\n  board() {\n    const output = []\n    let row = []\n\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n      if (this._board[i] == null) {\n        row.push(null)\n      } else {\n        row.push({\n          square: algebraic(i),\n          type: this._board[i].type,\n          color: this._board[i].color,\n        })\n      }\n      if ((i + 1) & 0x88) {\n        output.push(row)\n        row = []\n        i += 8\n      }\n    }\n\n    return output\n  }\n\n  squareColor(square: Square) {\n    if (square in Ox88) {\n      const sq = Ox88[square]\n      return (rank(sq) + file(sq)) % 2 === 0 ? 'light' : 'dark'\n    }\n\n    return null\n  }\n\n  history(): string[]\n  history({ verbose }: { verbose: true }): Move[]\n  history({ verbose }: { verbose: false }): string[]\n  history({ verbose }: { verbose: boolean }): string[] | Move[]\n  history({ verbose = false }: { verbose?: boolean } = {}) {\n    const reversedHistory = []\n    const moveHistory = []\n\n    while (this._history.length > 0) {\n      reversedHistory.push(this._undoMove())\n    }\n\n    while (true) {\n      const move = reversedHistory.pop()\n      if (!move) {\n        break\n      }\n\n      if (verbose) {\n        moveHistory.push(this._makePretty(move))\n      } else {\n        moveHistory.push(this._moveToSan(move, this._moves()))\n      }\n      this._makeMove(move)\n    }\n\n    return moveHistory\n  }\n\n  private _pruneComments() {\n    const reversedHistory = []\n    const currentComments: Record<string, string> = {}\n\n    const copyComment = (fen: string) => {\n      if (fen in this._comments) {\n        currentComments[fen] = this._comments[fen]\n      }\n    }\n\n    while (this._history.length > 0) {\n      reversedHistory.push(this._undoMove())\n    }\n\n    copyComment(this.fen())\n\n    while (true) {\n      const move = reversedHistory.pop()\n      if (!move) {\n        break\n      }\n      this._makeMove(move)\n      copyComment(this.fen())\n    }\n    this._comments = currentComments\n  }\n\n  getComment() {\n    return this._comments[this.fen()]\n  }\n\n  setComment(comment: string) {\n    this._comments[this.fen()] = comment.replace('{', '[').replace('}', ']')\n  }\n\n  deleteComment() {\n    const comment = this._comments[this.fen()]\n    delete this._comments[this.fen()]\n    return comment\n  }\n\n  getComments() {\n    this._pruneComments()\n    return Object.keys(this._comments).map((fen: string) => {\n      return { fen: fen, comment: this._comments[fen] }\n    })\n  }\n\n  deleteComments() {\n    this._pruneComments()\n    return Object.keys(this._comments).map((fen) => {\n      const comment = this._comments[fen]\n      delete this._comments[fen]\n      return { fen: fen, comment: comment }\n    })\n  }\n\n  setCastlingRights(color: Color, rights: Partial<Record<typeof KING | typeof QUEEN, boolean>>) {\n    for (const side of [KING, QUEEN] as const) {\n      if (rights[side] !== undefined) {\n        if (rights[side]) {\n          this._castling[color] |= SIDES[side]\n        } else {\n          this._castling[color] &= ~SIDES[side]\n        }\n      }\n    }\n\n    this._updateCastlingRights()\n    const result = this.getCastlingRights(color)\n\n    return (rights[KING] === undefined || rights[KING] === result[KING]) && (rights[QUEEN] === undefined || rights[QUEEN] === result[QUEEN])\n  }\n\n  getCastlingRights(color: Color) {\n    return {\n      [KING]: (this._castling[color] & SIDES[KING]) !== 0,\n      [QUEEN]: (this._castling[color] & SIDES[QUEEN]) !== 0,\n    }\n  }\n\n  moveNumber() {\n    return this._moveNumber\n  }\n}\n"],"mappings":"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C,EAAE,CAAC,EAAE,EAAE,EAAG,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAC,EAAE,EAAE,CAAC,EAChD,CAAC,EAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAG,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EAChD,CAAC,EAAE,CAAC,EAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAG,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAChD,CAAC,EAAE,CAAC,EAAE,CAAC,EAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAG,CAAC,EAAE,CAAC,EAAE,CAAC,EAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAChD,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAG,CAAC,EAAE,CAAC,EAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAChD,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAC,EAAE,EAAE,CAAC,EAAE,EAAE,EAAG,CAAC,EAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAChD,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EACjD,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAG,CAAC,EAAE,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAE,CAAC,EAChD,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAChD,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAC,EAAE,EAAE,CAAC,EAAE,EAAE,EAAG,CAAC,EAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAChD,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAG,CAAC,EAAE,CAAC,EAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAChD,CAAC,EAAE,CAAC,EAAE,CAAC,EAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAG,CAAC,EAAE,CAAC,EAAE,CAAC,EAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAChD,CAAC,EAAE,CAAC,EAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAG,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAChD,CAAC,EAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAG,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EACjD,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAG,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAC,EAAE,CAC/C;AAED;AACA,IAAMC,IAAI,GAAG,CACV,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,EAAE,EAAE,CAAC,EAC5D,CAAC,EAAE,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,EAAE,EAAG,CAAC,EAAE,CAAC,EAC5D,CAAC,EAAG,CAAC,EAAE,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,EAAE,EAAG,CAAC,EAAG,CAAC,EAAE,CAAC,EAC5D,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,CAAC,EAC5D,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,EAAE,EAAG,CAAC,EAAG,CAAC,EAAE,EAAE,EAAG,CAAC,EAAG,CAAC,EAAE,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,CAAC,EAC5D,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,EAAE,EAAG,CAAC,EAAE,EAAE,EAAG,CAAC,EAAE,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,CAAC,EAC5D,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,CAAC,EAC5D,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAG,CAAC,CAAC,EAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAC5D,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAC,CAAC,EAAE,EAAC,CAAC,EAAE,EAAC,CAAC,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,CAAC,EAC5D,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAC,CAAC,EAAE,EAAG,CAAC,EAAC,CAAC,EAAE,EAAG,CAAC,EAAC,CAAC,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,CAAC,EAC5D,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAC,CAAC,EAAE,EAAG,CAAC,EAAG,CAAC,EAAC,CAAC,EAAE,EAAG,CAAC,EAAG,CAAC,EAAC,CAAC,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,CAAC,EAC5D,CAAC,EAAG,CAAC,EAAG,CAAC,EAAC,CAAC,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAC,CAAC,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAC,CAAC,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,CAAC,EAC5D,CAAC,EAAG,CAAC,EAAC,CAAC,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAC,CAAC,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAC,CAAC,EAAE,EAAG,CAAC,EAAG,CAAC,EAAE,CAAC,EAC5D,CAAC,EAAC,CAAC,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAC,CAAC,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAC,CAAC,EAAE,EAAG,CAAC,EAAE,CAAC,EAC9D,CAAC,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAA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"},"metadata":{},"sourceType":"module","externalDependencies":[]}